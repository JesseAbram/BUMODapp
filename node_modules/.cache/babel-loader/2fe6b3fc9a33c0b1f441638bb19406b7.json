{"ast":null,"code":"(function (nacl) {\n  'use strict';\n\n  var u64 = function u64(h, l) {\n    this.hi = h | 0 >>> 0;\n    this.lo = l | 0 >>> 0;\n  };\n\n  var gf = function gf(init) {\n    var i,\n        r = new Float64Array(16);\n    if (init) for (i = 0; i < init.length; i++) {\n      r[i] = init[i];\n    }\n    return r;\n  };\n\n  var randombytes = function randombytes() {\n    throw new Error('no PRNG');\n  };\n\n  var _0 = new Uint8Array(16);\n\n  var _9 = new Uint8Array(32);\n\n  _9[0] = 9;\n\n  var gf0 = gf(),\n      gf1 = gf([1]),\n      _121665 = gf([0xdb41, 1]),\n      D = gf([0x78a3, 0x1359, 0x4dca, 0x75eb, 0xd8ab, 0x4141, 0x0a4d, 0x0070, 0xe898, 0x7779, 0x4079, 0x8cc7, 0xfe73, 0x2b6f, 0x6cee, 0x5203]),\n      D2 = gf([0xf159, 0x26b2, 0x9b94, 0xebd6, 0xb156, 0x8283, 0x149a, 0x00e0, 0xd130, 0xeef3, 0x80f2, 0x198e, 0xfce7, 0x56df, 0xd9dc, 0x2406]),\n      X = gf([0xd51a, 0x8f25, 0x2d60, 0xc956, 0xa7b2, 0x9525, 0xc760, 0x692c, 0xdc5c, 0xfdd6, 0xe231, 0xc0a4, 0x53fe, 0xcd6e, 0x36d3, 0x2169]),\n      Y = gf([0x6658, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666]),\n      I = gf([0xa0b0, 0x4a0e, 0x1b27, 0xc4ee, 0xe478, 0xad2f, 0x1806, 0x2f43, 0xd7a7, 0x3dfb, 0x0099, 0x2b4d, 0xdf0b, 0x4fc1, 0x2480, 0x2b83]);\n\n  function L32(x, c) {\n    return x << c | x >>> 32 - c;\n  }\n\n  function ld32(x, i) {\n    var u = x[i + 3] & 0xff;\n    u = u << 8 | x[i + 2] & 0xff;\n    u = u << 8 | x[i + 1] & 0xff;\n    return u << 8 | x[i + 0] & 0xff;\n  }\n\n  function dl64(x, i) {\n    var h = x[i] << 24 | x[i + 1] << 16 | x[i + 2] << 8 | x[i + 3];\n    var l = x[i + 4] << 24 | x[i + 5] << 16 | x[i + 6] << 8 | x[i + 7];\n    return new u64(h, l);\n  }\n\n  function st32(x, j, u) {\n    var i;\n\n    for (i = 0; i < 4; i++) {\n      x[j + i] = u & 255;\n      u >>>= 8;\n    }\n  }\n\n  function ts64(x, i, u) {\n    x[i] = u.hi >> 24 & 0xff;\n    x[i + 1] = u.hi >> 16 & 0xff;\n    x[i + 2] = u.hi >> 8 & 0xff;\n    x[i + 3] = u.hi & 0xff;\n    x[i + 4] = u.lo >> 24 & 0xff;\n    x[i + 5] = u.lo >> 16 & 0xff;\n    x[i + 6] = u.lo >> 8 & 0xff;\n    x[i + 7] = u.lo & 0xff;\n  }\n\n  function vn(x, xi, y, yi, n) {\n    var i,\n        d = 0;\n\n    for (i = 0; i < n; i++) {\n      d |= x[xi + i] ^ y[yi + i];\n    }\n\n    return (1 & d - 1 >>> 8) - 1;\n  }\n\n  function crypto_verify_16(x, xi, y, yi) {\n    return vn(x, xi, y, yi, 16);\n  }\n\n  function crypto_verify_32(x, xi, y, yi) {\n    return vn(x, xi, y, yi, 32);\n  }\n\n  function core(out, inp, k, c, h) {\n    var w = new Uint32Array(16),\n        x = new Uint32Array(16),\n        y = new Uint32Array(16),\n        t = new Uint32Array(4);\n    var i, j, m;\n\n    for (i = 0; i < 4; i++) {\n      x[5 * i] = ld32(c, 4 * i);\n      x[1 + i] = ld32(k, 4 * i);\n      x[6 + i] = ld32(inp, 4 * i);\n      x[11 + i] = ld32(k, 16 + 4 * i);\n    }\n\n    for (i = 0; i < 16; i++) {\n      y[i] = x[i];\n    }\n\n    for (i = 0; i < 20; i++) {\n      for (j = 0; j < 4; j++) {\n        for (m = 0; m < 4; m++) {\n          t[m] = x[(5 * j + 4 * m) % 16];\n        }\n\n        t[1] ^= L32(t[0] + t[3] | 0, 7);\n        t[2] ^= L32(t[1] + t[0] | 0, 9);\n        t[3] ^= L32(t[2] + t[1] | 0, 13);\n        t[0] ^= L32(t[3] + t[2] | 0, 18);\n\n        for (m = 0; m < 4; m++) {\n          w[4 * j + (j + m) % 4] = t[m];\n        }\n      }\n\n      for (m = 0; m < 16; m++) {\n        x[m] = w[m];\n      }\n    }\n\n    if (h) {\n      for (i = 0; i < 16; i++) {\n        x[i] = x[i] + y[i] | 0;\n      }\n\n      for (i = 0; i < 4; i++) {\n        x[5 * i] = x[5 * i] - ld32(c, 4 * i) | 0;\n        x[6 + i] = x[6 + i] - ld32(inp, 4 * i) | 0;\n      }\n\n      for (i = 0; i < 4; i++) {\n        st32(out, 4 * i, x[5 * i]);\n        st32(out, 16 + 4 * i, x[6 + i]);\n      }\n    } else {\n      for (i = 0; i < 16; i++) {\n        st32(out, 4 * i, x[i] + y[i] | 0);\n      }\n    }\n  }\n\n  function crypto_core_salsa20(out, inp, k, c) {\n    core(out, inp, k, c, false);\n    return 0;\n  }\n\n  function crypto_core_hsalsa20(out, inp, k, c) {\n    core(out, inp, k, c, true);\n    return 0;\n  }\n\n  var sigma = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);\n\n  function crypto_stream_salsa20_xor(c, cpos, m, mpos, b, n, k) {\n    var z = new Uint8Array(16),\n        x = new Uint8Array(64);\n    var u, i;\n    if (!b) return 0;\n\n    for (i = 0; i < 16; i++) {\n      z[i] = 0;\n    }\n\n    for (i = 0; i < 8; i++) {\n      z[i] = n[i];\n    }\n\n    while (b >= 64) {\n      crypto_core_salsa20(x, z, k, sigma);\n\n      for (i = 0; i < 64; i++) {\n        c[cpos + i] = (m ? m[mpos + i] : 0) ^ x[i];\n      }\n\n      u = 1;\n\n      for (i = 8; i < 16; i++) {\n        u = u + (z[i] & 0xff) | 0;\n        z[i] = u & 0xff;\n        u >>>= 8;\n      }\n\n      b -= 64;\n      cpos += 64;\n      if (m) mpos += 64;\n    }\n\n    if (b > 0) {\n      crypto_core_salsa20(x, z, k, sigma);\n\n      for (i = 0; i < b; i++) {\n        c[cpos + i] = (m ? m[mpos + i] : 0) ^ x[i];\n      }\n    }\n\n    return 0;\n  }\n\n  function crypto_stream_salsa20(c, cpos, d, n, k) {\n    return crypto_stream_salsa20_xor(c, cpos, null, 0, d, n, k);\n  }\n\n  function crypto_stream(c, cpos, d, n, k) {\n    var s = new Uint8Array(32);\n    crypto_core_hsalsa20(s, n, k, sigma);\n    return crypto_stream_salsa20(c, cpos, d, n.subarray(16), s);\n  }\n\n  function crypto_stream_xor(c, cpos, m, mpos, d, n, k) {\n    var s = new Uint8Array(32);\n    crypto_core_hsalsa20(s, n, k, sigma);\n    return crypto_stream_salsa20_xor(c, cpos, m, mpos, d, n.subarray(16), s);\n  }\n\n  function add1305(h, c) {\n    var j,\n        u = 0;\n\n    for (j = 0; j < 17; j++) {\n      u = u + (h[j] + c[j] | 0) | 0;\n      h[j] = u & 255;\n      u >>>= 8;\n    }\n  }\n\n  var minusp = new Uint32Array([5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 252]);\n\n  function crypto_onetimeauth(out, outpos, m, mpos, n, k) {\n    var s, i, j, u;\n    var x = new Uint32Array(17),\n        r = new Uint32Array(17),\n        h = new Uint32Array(17),\n        c = new Uint32Array(17),\n        g = new Uint32Array(17);\n\n    for (j = 0; j < 17; j++) {\n      r[j] = h[j] = 0;\n    }\n\n    for (j = 0; j < 16; j++) {\n      r[j] = k[j];\n    }\n\n    r[3] &= 15;\n    r[4] &= 252;\n    r[7] &= 15;\n    r[8] &= 252;\n    r[11] &= 15;\n    r[12] &= 252;\n    r[15] &= 15;\n\n    while (n > 0) {\n      for (j = 0; j < 17; j++) {\n        c[j] = 0;\n      }\n\n      for (j = 0; j < 16 && j < n; ++j) {\n        c[j] = m[mpos + j];\n      }\n\n      c[j] = 1;\n      mpos += j;\n      n -= j;\n      add1305(h, c);\n\n      for (i = 0; i < 17; i++) {\n        x[i] = 0;\n\n        for (j = 0; j < 17; j++) {\n          x[i] = x[i] + h[j] * (j <= i ? r[i - j] : 320 * r[i + 17 - j] | 0) | 0 | 0;\n        }\n      }\n\n      for (i = 0; i < 17; i++) {\n        h[i] = x[i];\n      }\n\n      u = 0;\n\n      for (j = 0; j < 16; j++) {\n        u = u + h[j] | 0;\n        h[j] = u & 255;\n        u >>>= 8;\n      }\n\n      u = u + h[16] | 0;\n      h[16] = u & 3;\n      u = 5 * (u >>> 2) | 0;\n\n      for (j = 0; j < 16; j++) {\n        u = u + h[j] | 0;\n        h[j] = u & 255;\n        u >>>= 8;\n      }\n\n      u = u + h[16] | 0;\n      h[16] = u;\n    }\n\n    for (j = 0; j < 17; j++) {\n      g[j] = h[j];\n    }\n\n    add1305(h, minusp);\n    s = -(h[16] >>> 7) | 0;\n\n    for (j = 0; j < 17; j++) {\n      h[j] ^= s & (g[j] ^ h[j]);\n    }\n\n    for (j = 0; j < 16; j++) {\n      c[j] = k[j + 16];\n    }\n\n    c[16] = 0;\n    add1305(h, c);\n\n    for (j = 0; j < 16; j++) {\n      out[outpos + j] = h[j];\n    }\n\n    return 0;\n  }\n\n  function crypto_onetimeauth_verify(h, hpos, m, mpos, n, k) {\n    var x = new Uint8Array(16);\n    crypto_onetimeauth(x, 0, m, mpos, n, k);\n    return crypto_verify_16(h, hpos, x, 0);\n  }\n\n  function crypto_secretbox(c, m, d, n, k) {\n    var i;\n    if (d < 32) return -1;\n    crypto_stream_xor(c, 0, m, 0, d, n, k);\n    crypto_onetimeauth(c, 16, c, 32, d - 32, c);\n\n    for (i = 0; i < 16; i++) {\n      c[i] = 0;\n    }\n\n    return 0;\n  }\n\n  function crypto_secretbox_open(m, c, d, n, k) {\n    var i;\n    var x = new Uint8Array(32);\n    if (d < 32) return -1;\n    crypto_stream(x, 0, 32, n, k);\n    if (crypto_onetimeauth_verify(c, 16, c, 32, d - 32, x) !== 0) return -1;\n    crypto_stream_xor(m, 0, c, 0, d, n, k);\n\n    for (i = 0; i < 32; i++) {\n      m[i] = 0;\n    }\n\n    return 0;\n  }\n\n  function set25519(r, a) {\n    var i;\n\n    for (i = 0; i < 16; i++) {\n      r[i] = a[i] | 0;\n    }\n  }\n\n  function car25519(o) {\n    var c;\n    var i;\n\n    for (i = 0; i < 16; i++) {\n      o[i] += 65536;\n      c = Math.floor(o[i] / 65536);\n      o[(i + 1) * (i < 15 ? 1 : 0)] += c - 1 + 37 * (c - 1) * (i === 15 ? 1 : 0);\n      o[i] -= c * 65536;\n    }\n  }\n\n  function sel25519(p, q, b) {\n    var t,\n        c = ~(b - 1);\n\n    for (var i = 0; i < 16; i++) {\n      t = c & (p[i] ^ q[i]);\n      p[i] ^= t;\n      q[i] ^= t;\n    }\n  }\n\n  function pack25519(o, n) {\n    var i, j, b;\n    var m = gf(),\n        t = gf();\n\n    for (i = 0; i < 16; i++) {\n      t[i] = n[i];\n    }\n\n    car25519(t);\n    car25519(t);\n    car25519(t);\n\n    for (j = 0; j < 2; j++) {\n      m[0] = t[0] - 0xffed;\n\n      for (i = 1; i < 15; i++) {\n        m[i] = t[i] - 0xffff - (m[i - 1] >> 16 & 1);\n        m[i - 1] &= 0xffff;\n      }\n\n      m[15] = t[15] - 0x7fff - (m[14] >> 16 & 1);\n      b = m[15] >> 16 & 1;\n      m[14] &= 0xffff;\n      sel25519(t, m, 1 - b);\n    }\n\n    for (i = 0; i < 16; i++) {\n      o[2 * i] = t[i] & 0xff;\n      o[2 * i + 1] = t[i] >> 8;\n    }\n  }\n\n  function neq25519(a, b) {\n    var c = new Uint8Array(32),\n        d = new Uint8Array(32);\n    pack25519(c, a);\n    pack25519(d, b);\n    return crypto_verify_32(c, 0, d, 0);\n  }\n\n  function par25519(a) {\n    var d = new Uint8Array(32);\n    pack25519(d, a);\n    return d[0] & 1;\n  }\n\n  function unpack25519(o, n) {\n    var i;\n\n    for (i = 0; i < 16; i++) {\n      o[i] = n[2 * i] + (n[2 * i + 1] << 8);\n    }\n\n    o[15] &= 0x7fff;\n  }\n\n  function A(o, a, b) {\n    var i;\n\n    for (i = 0; i < 16; i++) {\n      o[i] = a[i] + b[i] | 0;\n    }\n  }\n\n  function Z(o, a, b) {\n    var i;\n\n    for (i = 0; i < 16; i++) {\n      o[i] = a[i] - b[i] | 0;\n    }\n  }\n\n  function M(o, a, b) {\n    var i,\n        j,\n        t = new Float64Array(31);\n\n    for (i = 0; i < 31; i++) {\n      t[i] = 0;\n    }\n\n    for (i = 0; i < 16; i++) {\n      for (j = 0; j < 16; j++) {\n        t[i + j] += a[i] * b[j];\n      }\n    }\n\n    for (i = 0; i < 15; i++) {\n      t[i] += 38 * t[i + 16];\n    }\n\n    for (i = 0; i < 16; i++) {\n      o[i] = t[i];\n    }\n\n    car25519(o);\n    car25519(o);\n  }\n\n  function S(o, a) {\n    M(o, a, a);\n  }\n\n  function inv25519(o, i) {\n    var c = gf();\n    var a;\n\n    for (a = 0; a < 16; a++) {\n      c[a] = i[a];\n    }\n\n    for (a = 253; a >= 0; a--) {\n      S(c, c);\n      if (a !== 2 && a !== 4) M(c, c, i);\n    }\n\n    for (a = 0; a < 16; a++) {\n      o[a] = c[a];\n    }\n  }\n\n  function pow2523(o, i) {\n    var c = gf();\n    var a;\n\n    for (a = 0; a < 16; a++) {\n      c[a] = i[a];\n    }\n\n    for (a = 250; a >= 0; a--) {\n      S(c, c);\n      if (a !== 1) M(c, c, i);\n    }\n\n    for (a = 0; a < 16; a++) {\n      o[a] = c[a];\n    }\n  }\n\n  function crypto_scalarmult(q, n, p) {\n    var z = new Uint8Array(32);\n    var x = new Float64Array(80),\n        r,\n        i;\n    var a = gf(),\n        b = gf(),\n        c = gf(),\n        d = gf(),\n        e = gf(),\n        f = gf();\n\n    for (i = 0; i < 31; i++) {\n      z[i] = n[i];\n    }\n\n    z[31] = n[31] & 127 | 64;\n    z[0] &= 248;\n    unpack25519(x, p);\n\n    for (i = 0; i < 16; i++) {\n      b[i] = x[i];\n      d[i] = a[i] = c[i] = 0;\n    }\n\n    a[0] = d[0] = 1;\n\n    for (i = 254; i >= 0; --i) {\n      r = z[i >>> 3] >>> (i & 7) & 1;\n      sel25519(a, b, r);\n      sel25519(c, d, r);\n      A(e, a, c);\n      Z(a, a, c);\n      A(c, b, d);\n      Z(b, b, d);\n      S(d, e);\n      S(f, a);\n      M(a, c, a);\n      M(c, b, e);\n      A(e, a, c);\n      Z(a, a, c);\n      S(b, a);\n      Z(c, d, f);\n      M(a, c, _121665);\n      A(a, a, d);\n      M(c, c, a);\n      M(a, d, f);\n      M(d, b, x);\n      S(b, e);\n      sel25519(a, b, r);\n      sel25519(c, d, r);\n    }\n\n    for (i = 0; i < 16; i++) {\n      x[i + 16] = a[i];\n      x[i + 32] = c[i];\n      x[i + 48] = b[i];\n      x[i + 64] = d[i];\n    }\n\n    var x32 = x.subarray(32);\n    var x16 = x.subarray(16);\n    inv25519(x32, x32);\n    M(x16, x16, x32);\n    pack25519(q, x16);\n    return 0;\n  }\n\n  function crypto_scalarmult_base(q, n) {\n    return crypto_scalarmult(q, n, _9);\n  }\n\n  function crypto_box_keypair(y, x) {\n    randombytes(x, 32);\n    return crypto_scalarmult_base(y, x);\n  }\n\n  function crypto_box_beforenm(k, y, x) {\n    var s = new Uint8Array(32);\n    crypto_scalarmult(s, x, y);\n    return crypto_core_hsalsa20(k, _0, s, sigma);\n  }\n\n  var crypto_box_afternm = crypto_secretbox;\n  var crypto_box_open_afternm = crypto_secretbox_open;\n\n  function crypto_box(c, m, d, n, y, x) {\n    var k = new Uint8Array(32);\n    crypto_box_beforenm(k, y, x);\n    return crypto_box_afternm(c, m, d, n, k);\n  }\n\n  function crypto_box_open(m, c, d, n, y, x) {\n    var k = new Uint8Array(32);\n    crypto_box_beforenm(k, y, x);\n    return crypto_box_open_afternm(m, c, d, n, k);\n  }\n\n  function add64() {\n    var a = 0,\n        b = 0,\n        c = 0,\n        d = 0,\n        m16 = 65535,\n        l,\n        h,\n        i;\n\n    for (i = 0; i < arguments.length; i++) {\n      l = arguments[i].lo;\n      h = arguments[i].hi;\n      a += l & m16;\n      b += l >>> 16;\n      c += h & m16;\n      d += h >>> 16;\n    }\n\n    b += a >>> 16;\n    c += b >>> 16;\n    d += c >>> 16;\n    return new u64(c & m16 | d << 16, a & m16 | b << 16);\n  }\n\n  function shr64(x, c) {\n    return new u64(x.hi >>> c, x.lo >>> c | x.hi << 32 - c);\n  }\n\n  function xor64() {\n    var l = 0,\n        h = 0,\n        i;\n\n    for (i = 0; i < arguments.length; i++) {\n      l ^= arguments[i].lo;\n      h ^= arguments[i].hi;\n    }\n\n    return new u64(h, l);\n  }\n\n  function R(x, c) {\n    var h,\n        l,\n        c1 = 32 - c;\n\n    if (c < 32) {\n      h = x.hi >>> c | x.lo << c1;\n      l = x.lo >>> c | x.hi << c1;\n    } else if (c < 64) {\n      h = x.lo >>> c | x.hi << c1;\n      l = x.hi >>> c | x.lo << c1;\n    }\n\n    return new u64(h, l);\n  }\n\n  function Ch(x, y, z) {\n    var h = x.hi & y.hi ^ ~x.hi & z.hi,\n        l = x.lo & y.lo ^ ~x.lo & z.lo;\n    return new u64(h, l);\n  }\n\n  function Maj(x, y, z) {\n    var h = x.hi & y.hi ^ x.hi & z.hi ^ y.hi & z.hi,\n        l = x.lo & y.lo ^ x.lo & z.lo ^ y.lo & z.lo;\n    return new u64(h, l);\n  }\n\n  function Sigma0(x) {\n    return xor64(R(x, 28), R(x, 34), R(x, 39));\n  }\n\n  function Sigma1(x) {\n    return xor64(R(x, 14), R(x, 18), R(x, 41));\n  }\n\n  function sigma0(x) {\n    return xor64(R(x, 1), R(x, 8), shr64(x, 7));\n  }\n\n  function sigma1(x) {\n    return xor64(R(x, 19), R(x, 61), shr64(x, 6));\n  }\n\n  var K = [new u64(0x428a2f98, 0xd728ae22), new u64(0x71374491, 0x23ef65cd), new u64(0xb5c0fbcf, 0xec4d3b2f), new u64(0xe9b5dba5, 0x8189dbbc), new u64(0x3956c25b, 0xf348b538), new u64(0x59f111f1, 0xb605d019), new u64(0x923f82a4, 0xaf194f9b), new u64(0xab1c5ed5, 0xda6d8118), new u64(0xd807aa98, 0xa3030242), new u64(0x12835b01, 0x45706fbe), new u64(0x243185be, 0x4ee4b28c), new u64(0x550c7dc3, 0xd5ffb4e2), new u64(0x72be5d74, 0xf27b896f), new u64(0x80deb1fe, 0x3b1696b1), new u64(0x9bdc06a7, 0x25c71235), new u64(0xc19bf174, 0xcf692694), new u64(0xe49b69c1, 0x9ef14ad2), new u64(0xefbe4786, 0x384f25e3), new u64(0x0fc19dc6, 0x8b8cd5b5), new u64(0x240ca1cc, 0x77ac9c65), new u64(0x2de92c6f, 0x592b0275), new u64(0x4a7484aa, 0x6ea6e483), new u64(0x5cb0a9dc, 0xbd41fbd4), new u64(0x76f988da, 0x831153b5), new u64(0x983e5152, 0xee66dfab), new u64(0xa831c66d, 0x2db43210), new u64(0xb00327c8, 0x98fb213f), new u64(0xbf597fc7, 0xbeef0ee4), new u64(0xc6e00bf3, 0x3da88fc2), new u64(0xd5a79147, 0x930aa725), new u64(0x06ca6351, 0xe003826f), new u64(0x14292967, 0x0a0e6e70), new u64(0x27b70a85, 0x46d22ffc), new u64(0x2e1b2138, 0x5c26c926), new u64(0x4d2c6dfc, 0x5ac42aed), new u64(0x53380d13, 0x9d95b3df), new u64(0x650a7354, 0x8baf63de), new u64(0x766a0abb, 0x3c77b2a8), new u64(0x81c2c92e, 0x47edaee6), new u64(0x92722c85, 0x1482353b), new u64(0xa2bfe8a1, 0x4cf10364), new u64(0xa81a664b, 0xbc423001), new u64(0xc24b8b70, 0xd0f89791), new u64(0xc76c51a3, 0x0654be30), new u64(0xd192e819, 0xd6ef5218), new u64(0xd6990624, 0x5565a910), new u64(0xf40e3585, 0x5771202a), new u64(0x106aa070, 0x32bbd1b8), new u64(0x19a4c116, 0xb8d2d0c8), new u64(0x1e376c08, 0x5141ab53), new u64(0x2748774c, 0xdf8eeb99), new u64(0x34b0bcb5, 0xe19b48a8), new u64(0x391c0cb3, 0xc5c95a63), new u64(0x4ed8aa4a, 0xe3418acb), new u64(0x5b9cca4f, 0x7763e373), new u64(0x682e6ff3, 0xd6b2b8a3), new u64(0x748f82ee, 0x5defb2fc), new u64(0x78a5636f, 0x43172f60), new u64(0x84c87814, 0xa1f0ab72), new u64(0x8cc70208, 0x1a6439ec), new u64(0x90befffa, 0x23631e28), new u64(0xa4506ceb, 0xde82bde9), new u64(0xbef9a3f7, 0xb2c67915), new u64(0xc67178f2, 0xe372532b), new u64(0xca273ece, 0xea26619c), new u64(0xd186b8c7, 0x21c0c207), new u64(0xeada7dd6, 0xcde0eb1e), new u64(0xf57d4f7f, 0xee6ed178), new u64(0x06f067aa, 0x72176fba), new u64(0x0a637dc5, 0xa2c898a6), new u64(0x113f9804, 0xbef90dae), new u64(0x1b710b35, 0x131c471b), new u64(0x28db77f5, 0x23047d84), new u64(0x32caab7b, 0x40c72493), new u64(0x3c9ebe0a, 0x15c9bebc), new u64(0x431d67c4, 0x9c100d4c), new u64(0x4cc5d4be, 0xcb3e42b6), new u64(0x597f299c, 0xfc657e2a), new u64(0x5fcb6fab, 0x3ad6faec), new u64(0x6c44198c, 0x4a475817)];\n\n  function crypto_hashblocks(x, m, n) {\n    var z = [],\n        b = [],\n        a = [],\n        w = [],\n        t,\n        i,\n        j;\n\n    for (i = 0; i < 8; i++) {\n      z[i] = a[i] = dl64(x, 8 * i);\n    }\n\n    var pos = 0;\n\n    while (n >= 128) {\n      for (i = 0; i < 16; i++) {\n        w[i] = dl64(m, 8 * i + pos);\n      }\n\n      for (i = 0; i < 80; i++) {\n        for (j = 0; j < 8; j++) {\n          b[j] = a[j];\n        }\n\n        t = add64(a[7], Sigma1(a[4]), Ch(a[4], a[5], a[6]), K[i], w[i % 16]);\n        b[7] = add64(t, Sigma0(a[0]), Maj(a[0], a[1], a[2]));\n        b[3] = add64(b[3], t);\n\n        for (j = 0; j < 8; j++) {\n          a[(j + 1) % 8] = b[j];\n        }\n\n        if (i % 16 === 15) {\n          for (j = 0; j < 16; j++) {\n            w[j] = add64(w[j], w[(j + 9) % 16], sigma0(w[(j + 1) % 16]), sigma1(w[(j + 14) % 16]));\n          }\n        }\n      }\n\n      for (i = 0; i < 8; i++) {\n        a[i] = add64(a[i], z[i]);\n        z[i] = a[i];\n      }\n\n      pos += 128;\n      n -= 128;\n    }\n\n    for (i = 0; i < 8; i++) {\n      ts64(x, 8 * i, z[i]);\n    }\n\n    return n;\n  }\n\n  var iv = new Uint8Array([0x6a, 0x09, 0xe6, 0x67, 0xf3, 0xbc, 0xc9, 0x08, 0xbb, 0x67, 0xae, 0x85, 0x84, 0xca, 0xa7, 0x3b, 0x3c, 0x6e, 0xf3, 0x72, 0xfe, 0x94, 0xf8, 0x2b, 0xa5, 0x4f, 0xf5, 0x3a, 0x5f, 0x1d, 0x36, 0xf1, 0x51, 0x0e, 0x52, 0x7f, 0xad, 0xe6, 0x82, 0xd1, 0x9b, 0x05, 0x68, 0x8c, 0x2b, 0x3e, 0x6c, 0x1f, 0x1f, 0x83, 0xd9, 0xab, 0xfb, 0x41, 0xbd, 0x6b, 0x5b, 0xe0, 0xcd, 0x19, 0x13, 0x7e, 0x21, 0x79]);\n\n  function crypto_hash(out, m, n) {\n    var h = new Uint8Array(64),\n        x = new Uint8Array(256);\n    var i,\n        b = n;\n\n    for (i = 0; i < 64; i++) {\n      h[i] = iv[i];\n    }\n\n    crypto_hashblocks(h, m, n);\n    n %= 128;\n\n    for (i = 0; i < 256; i++) {\n      x[i] = 0;\n    }\n\n    for (i = 0; i < n; i++) {\n      x[i] = m[b - n + i];\n    }\n\n    x[n] = 128;\n    n = 256 - 128 * (n < 112 ? 1 : 0);\n    x[n - 9] = 0;\n    ts64(x, n - 8, new u64(b / 0x20000000 | 0, b << 3));\n    crypto_hashblocks(h, x, n);\n\n    for (i = 0; i < 64; i++) {\n      out[i] = h[i];\n    }\n\n    return 0;\n  }\n\n  function add(p, q) {\n    var a = gf(),\n        b = gf(),\n        c = gf(),\n        d = gf(),\n        e = gf(),\n        f = gf(),\n        g = gf(),\n        h = gf(),\n        t = gf();\n    Z(a, p[1], p[0]);\n    Z(t, q[1], q[0]);\n    M(a, a, t);\n    A(b, p[0], p[1]);\n    A(t, q[0], q[1]);\n    M(b, b, t);\n    M(c, p[3], q[3]);\n    M(c, c, D2);\n    M(d, p[2], q[2]);\n    A(d, d, d);\n    Z(e, b, a);\n    Z(f, d, c);\n    A(g, d, c);\n    A(h, b, a);\n    M(p[0], e, f);\n    M(p[1], h, g);\n    M(p[2], g, f);\n    M(p[3], e, h);\n  }\n\n  function cswap(p, q, b) {\n    var i;\n\n    for (i = 0; i < 4; i++) {\n      sel25519(p[i], q[i], b);\n    }\n  }\n\n  function pack(r, p) {\n    var tx = gf(),\n        ty = gf(),\n        zi = gf();\n    inv25519(zi, p[2]);\n    M(tx, p[0], zi);\n    M(ty, p[1], zi);\n    pack25519(r, ty);\n    r[31] ^= par25519(tx) << 7;\n  }\n\n  function scalarmult(p, q, s) {\n    var b, i;\n    set25519(p[0], gf0);\n    set25519(p[1], gf1);\n    set25519(p[2], gf1);\n    set25519(p[3], gf0);\n\n    for (i = 255; i >= 0; --i) {\n      b = s[i / 8 | 0] >> (i & 7) & 1;\n      cswap(p, q, b);\n      add(q, p);\n      add(p, p);\n      cswap(p, q, b);\n    }\n  }\n\n  function scalarbase(p, s) {\n    var q = [gf(), gf(), gf(), gf()];\n    set25519(q[0], X);\n    set25519(q[1], Y);\n    set25519(q[2], gf1);\n    M(q[3], X, Y);\n    scalarmult(p, q, s);\n  }\n\n  function crypto_sign_keypair(pk, sk, seeded) {\n    var d = new Uint8Array(64);\n    var p = [gf(), gf(), gf(), gf()];\n    var i;\n    if (!seeded) randombytes(sk, 32);\n    crypto_hash(d, sk, 32);\n    d[0] &= 248;\n    d[31] &= 127;\n    d[31] |= 64;\n    scalarbase(p, d);\n    pack(pk, p);\n\n    for (i = 0; i < 32; i++) {\n      sk[i + 32] = pk[i];\n    }\n\n    return 0;\n  }\n\n  var L = new Float64Array([0xed, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58, 0xd6, 0x9c, 0xf7, 0xa2, 0xde, 0xf9, 0xde, 0x14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x10]);\n\n  function modL(r, x) {\n    var carry, i, j, k;\n\n    for (i = 63; i >= 32; --i) {\n      carry = 0;\n\n      for (j = i - 32, k = i - 12; j < k; ++j) {\n        x[j] += carry - 16 * x[i] * L[j - (i - 32)];\n        carry = x[j] + 128 >> 8;\n        x[j] -= carry * 256;\n      }\n\n      x[j] += carry;\n      x[i] = 0;\n    }\n\n    carry = 0;\n\n    for (j = 0; j < 32; j++) {\n      x[j] += carry - (x[31] >> 4) * L[j];\n      carry = x[j] >> 8;\n      x[j] &= 255;\n    }\n\n    for (j = 0; j < 32; j++) {\n      x[j] -= carry * L[j];\n    }\n\n    for (i = 0; i < 32; i++) {\n      x[i + 1] += x[i] >> 8;\n      r[i] = x[i] & 255;\n    }\n  }\n\n  function reduce(r) {\n    var x = new Float64Array(64),\n        i;\n\n    for (i = 0; i < 64; i++) {\n      x[i] = r[i];\n    }\n\n    for (i = 0; i < 64; i++) {\n      r[i] = 0;\n    }\n\n    modL(r, x);\n  }\n\n  function crypto_sign(sm, m, n, sk) {\n    var d = new Uint8Array(64),\n        h = new Uint8Array(64),\n        r = new Uint8Array(64);\n    var i,\n        j,\n        x = new Float64Array(64);\n    var p = [gf(), gf(), gf(), gf()];\n    crypto_hash(d, sk, 32);\n    d[0] &= 248;\n    d[31] &= 127;\n    d[31] |= 64;\n    var smlen = n + 64;\n\n    for (i = 0; i < n; i++) {\n      sm[64 + i] = m[i];\n    }\n\n    for (i = 0; i < 32; i++) {\n      sm[32 + i] = d[32 + i];\n    }\n\n    crypto_hash(r, sm.subarray(32), n + 32);\n    reduce(r);\n    scalarbase(p, r);\n    pack(sm, p);\n\n    for (i = 32; i < 64; i++) {\n      sm[i] = sk[i];\n    }\n\n    crypto_hash(h, sm, n + 64);\n    reduce(h);\n\n    for (i = 0; i < 64; i++) {\n      x[i] = 0;\n    }\n\n    for (i = 0; i < 32; i++) {\n      x[i] = r[i];\n    }\n\n    for (i = 0; i < 32; i++) {\n      for (j = 0; j < 32; j++) {\n        x[i + j] += h[i] * d[j];\n      }\n    }\n\n    modL(sm.subarray(32), x);\n    return smlen;\n  }\n\n  function unpackneg(r, p) {\n    var t = gf(),\n        chk = gf(),\n        num = gf(),\n        den = gf(),\n        den2 = gf(),\n        den4 = gf(),\n        den6 = gf();\n    set25519(r[2], gf1);\n    unpack25519(r[1], p);\n    S(num, r[1]);\n    M(den, num, D);\n    Z(num, num, r[2]);\n    A(den, r[2], den);\n    S(den2, den);\n    S(den4, den2);\n    M(den6, den4, den2);\n    M(t, den6, num);\n    M(t, t, den);\n    pow2523(t, t);\n    M(t, t, num);\n    M(t, t, den);\n    M(t, t, den);\n    M(r[0], t, den);\n    S(chk, r[0]);\n    M(chk, chk, den);\n    if (neq25519(chk, num)) M(r[0], r[0], I);\n    S(chk, r[0]);\n    M(chk, chk, den);\n    if (neq25519(chk, num)) return -1;\n    if (par25519(r[0]) === p[31] >> 7) Z(r[0], gf0, r[0]);\n    M(r[3], r[0], r[1]);\n    return 0;\n  }\n\n  function crypto_sign_open(m, sm, n, pk) {\n    var i, mlen;\n    var t = new Uint8Array(32),\n        h = new Uint8Array(64);\n    var p = [gf(), gf(), gf(), gf()],\n        q = [gf(), gf(), gf(), gf()];\n    mlen = -1;\n    if (n < 64) return -1;\n    if (unpackneg(q, pk)) return -1;\n\n    for (i = 0; i < n; i++) {\n      m[i] = sm[i];\n    }\n\n    for (i = 0; i < 32; i++) {\n      m[i + 32] = pk[i];\n    }\n\n    crypto_hash(h, m, n);\n    reduce(h);\n    scalarmult(p, q, h);\n    scalarbase(q, sm.subarray(32));\n    add(p, q);\n    pack(t, p);\n    n -= 64;\n\n    if (crypto_verify_32(sm, 0, t, 0)) {\n      for (i = 0; i < n; i++) {\n        m[i] = 0;\n      }\n\n      return -1;\n    }\n\n    for (i = 0; i < n; i++) {\n      m[i] = sm[i + 64];\n    }\n\n    mlen = n;\n    return mlen;\n  }\n\n  var crypto_secretbox_KEYBYTES = 32,\n      crypto_secretbox_NONCEBYTES = 24,\n      crypto_secretbox_ZEROBYTES = 32,\n      crypto_secretbox_BOXZEROBYTES = 16,\n      crypto_scalarmult_BYTES = 32,\n      crypto_scalarmult_SCALARBYTES = 32,\n      crypto_box_PUBLICKEYBYTES = 32,\n      crypto_box_SECRETKEYBYTES = 32,\n      crypto_box_BEFORENMBYTES = 32,\n      crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES,\n      crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES,\n      crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES,\n      crypto_sign_BYTES = 64,\n      crypto_sign_PUBLICKEYBYTES = 32,\n      crypto_sign_SECRETKEYBYTES = 64,\n      crypto_sign_SEEDBYTES = 32,\n      crypto_hash_BYTES = 64;\n  nacl.lowlevel = {\n    crypto_core_hsalsa20: crypto_core_hsalsa20,\n    crypto_stream_xor: crypto_stream_xor,\n    crypto_stream: crypto_stream,\n    crypto_stream_salsa20_xor: crypto_stream_salsa20_xor,\n    crypto_stream_salsa20: crypto_stream_salsa20,\n    crypto_onetimeauth: crypto_onetimeauth,\n    crypto_onetimeauth_verify: crypto_onetimeauth_verify,\n    crypto_verify_16: crypto_verify_16,\n    crypto_verify_32: crypto_verify_32,\n    crypto_secretbox: crypto_secretbox,\n    crypto_secretbox_open: crypto_secretbox_open,\n    crypto_scalarmult: crypto_scalarmult,\n    crypto_scalarmult_base: crypto_scalarmult_base,\n    crypto_box_beforenm: crypto_box_beforenm,\n    crypto_box_afternm: crypto_box_afternm,\n    crypto_box: crypto_box,\n    crypto_box_open: crypto_box_open,\n    crypto_box_keypair: crypto_box_keypair,\n    crypto_hash: crypto_hash,\n    crypto_sign: crypto_sign,\n    crypto_sign_keypair: crypto_sign_keypair,\n    crypto_sign_open: crypto_sign_open,\n    crypto_secretbox_KEYBYTES: crypto_secretbox_KEYBYTES,\n    crypto_secretbox_NONCEBYTES: crypto_secretbox_NONCEBYTES,\n    crypto_secretbox_ZEROBYTES: crypto_secretbox_ZEROBYTES,\n    crypto_secretbox_BOXZEROBYTES: crypto_secretbox_BOXZEROBYTES,\n    crypto_scalarmult_BYTES: crypto_scalarmult_BYTES,\n    crypto_scalarmult_SCALARBYTES: crypto_scalarmult_SCALARBYTES,\n    crypto_box_PUBLICKEYBYTES: crypto_box_PUBLICKEYBYTES,\n    crypto_box_SECRETKEYBYTES: crypto_box_SECRETKEYBYTES,\n    crypto_box_BEFORENMBYTES: crypto_box_BEFORENMBYTES,\n    crypto_box_NONCEBYTES: crypto_box_NONCEBYTES,\n    crypto_box_ZEROBYTES: crypto_box_ZEROBYTES,\n    crypto_box_BOXZEROBYTES: crypto_box_BOXZEROBYTES,\n    crypto_sign_BYTES: crypto_sign_BYTES,\n    crypto_sign_PUBLICKEYBYTES: crypto_sign_PUBLICKEYBYTES,\n    crypto_sign_SECRETKEYBYTES: crypto_sign_SECRETKEYBYTES,\n    crypto_sign_SEEDBYTES: crypto_sign_SEEDBYTES,\n    crypto_hash_BYTES: crypto_hash_BYTES\n  };\n\n  function checkLengths(k, n) {\n    if (k.length !== crypto_secretbox_KEYBYTES) throw new Error('bad key size');\n    if (n.length !== crypto_secretbox_NONCEBYTES) throw new Error('bad nonce size');\n  }\n\n  function checkBoxLengths(pk, sk) {\n    if (pk.length !== crypto_box_PUBLICKEYBYTES) throw new Error('bad public key size');\n    if (sk.length !== crypto_box_SECRETKEYBYTES) throw new Error('bad secret key size');\n  }\n\n  function checkArrayTypes() {\n    for (var i = 0; i < arguments.length; i++) {\n      if (!(arguments[i] instanceof Uint8Array)) throw new TypeError('unexpected type, use Uint8Array');\n    }\n  }\n\n  function cleanup(arr) {\n    for (var i = 0; i < arr.length; i++) {\n      arr[i] = 0;\n    }\n  }\n\n  nacl.randomBytes = function (n) {\n    var b = new Uint8Array(n);\n    randombytes(b, n);\n    return b;\n  };\n\n  nacl.secretbox = function (msg, nonce, key) {\n    checkArrayTypes(msg, nonce, key);\n    checkLengths(key, nonce);\n    var m = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);\n    var c = new Uint8Array(m.length);\n\n    for (var i = 0; i < msg.length; i++) {\n      m[i + crypto_secretbox_ZEROBYTES] = msg[i];\n    }\n\n    crypto_secretbox(c, m, m.length, nonce, key);\n    return c.subarray(crypto_secretbox_BOXZEROBYTES);\n  };\n\n  nacl.secretbox.open = function (box, nonce, key) {\n    checkArrayTypes(box, nonce, key);\n    checkLengths(key, nonce);\n    var c = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);\n    var m = new Uint8Array(c.length);\n\n    for (var i = 0; i < box.length; i++) {\n      c[i + crypto_secretbox_BOXZEROBYTES] = box[i];\n    }\n\n    if (c.length < 32) return null;\n    if (crypto_secretbox_open(m, c, c.length, nonce, key) !== 0) return null;\n    return m.subarray(crypto_secretbox_ZEROBYTES);\n  };\n\n  nacl.secretbox.keyLength = crypto_secretbox_KEYBYTES;\n  nacl.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;\n  nacl.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;\n\n  nacl.scalarMult = function (n, p) {\n    checkArrayTypes(n, p);\n    if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error('bad n size');\n    if (p.length !== crypto_scalarmult_BYTES) throw new Error('bad p size');\n    var q = new Uint8Array(crypto_scalarmult_BYTES);\n    crypto_scalarmult(q, n, p);\n    return q;\n  };\n\n  nacl.scalarMult.base = function (n) {\n    checkArrayTypes(n);\n    if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error('bad n size');\n    var q = new Uint8Array(crypto_scalarmult_BYTES);\n    crypto_scalarmult_base(q, n);\n    return q;\n  };\n\n  nacl.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;\n  nacl.scalarMult.groupElementLength = crypto_scalarmult_BYTES;\n\n  nacl.box = function (msg, nonce, publicKey, secretKey) {\n    var k = nacl.box.before(publicKey, secretKey);\n    return nacl.secretbox(msg, nonce, k);\n  };\n\n  nacl.box.before = function (publicKey, secretKey) {\n    checkArrayTypes(publicKey, secretKey);\n    checkBoxLengths(publicKey, secretKey);\n    var k = new Uint8Array(crypto_box_BEFORENMBYTES);\n    crypto_box_beforenm(k, publicKey, secretKey);\n    return k;\n  };\n\n  nacl.box.after = nacl.secretbox;\n\n  nacl.box.open = function (msg, nonce, publicKey, secretKey) {\n    var k = nacl.box.before(publicKey, secretKey);\n    return nacl.secretbox.open(msg, nonce, k);\n  };\n\n  nacl.box.open.after = nacl.secretbox.open;\n\n  nacl.box.keyPair = function () {\n    var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);\n    var sk = new Uint8Array(crypto_box_SECRETKEYBYTES);\n    crypto_box_keypair(pk, sk);\n    return {\n      publicKey: pk,\n      secretKey: sk\n    };\n  };\n\n  nacl.box.keyPair.fromSecretKey = function (secretKey) {\n    if (secretKey.length !== crypto_box_SECRETKEYBYTES) throw new Error('bad secret key size');\n    var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);\n    crypto_scalarmult_base(pk, secretKey);\n    return {\n      publicKey: pk,\n      secretKey: new Uint8Array(secretKey)\n    };\n  };\n\n  nacl.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;\n  nacl.box.secretKeyLength = crypto_box_SECRETKEYBYTES;\n  nacl.box.sharedKeyLength = crypto_box_BEFORENMBYTES;\n  nacl.box.nonceLength = crypto_box_NONCEBYTES;\n  nacl.box.overheadLength = nacl.secretbox.overheadLength;\n\n  nacl.sign = function (msg, secretKey) {\n    var signedMsg = new Uint8Array(crypto_sign_BYTES + msg.length);\n    crypto_sign(signedMsg, msg, msg.length, secretKey);\n    return signedMsg;\n  };\n\n  nacl.sign.open = function (signedMsg, publicKey) {\n    var tmp = new Uint8Array(signedMsg.length);\n    var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);\n    if (mlen < 0) return null;\n    var m = new Uint8Array(mlen);\n\n    for (var i = 0; i < m.length; i++) {\n      m[i] = tmp[i];\n    }\n\n    return m;\n  };\n\n  nacl.sign.detached = function (msg, secretKey) {\n    var signedMsg = nacl.sign(msg, secretKey);\n    var sig = new Uint8Array(crypto_sign_BYTES);\n\n    for (var i = 0; i < sig.length; i++) {\n      sig[i] = signedMsg[i];\n    }\n\n    return sig;\n  };\n\n  nacl.sign.detached.verify = function (msg, sig, publicKey) {\n    var sm = new Uint8Array(crypto_sign_BYTES + msg.length);\n    var m = new Uint8Array(crypto_sign_BYTES + msg.length);\n    var i;\n\n    for (i = 0; i < crypto_sign_BYTES; i++) {\n      sm[i] = sig[i];\n    }\n\n    for (i = 0; i < msg.length; i++) {\n      sm[i + crypto_sign_BYTES] = msg[i];\n    }\n\n    return crypto_sign_open(m, sm, sm.length, publicKey) >= 0;\n  };\n\n  nacl.sign.keyPair = function () {\n    var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);\n    var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);\n    crypto_sign_keypair(pk, sk);\n    return {\n      publicKey: pk,\n      secretKey: sk\n    };\n  };\n\n  nacl.sign.keyPair.fromSecretKey = function (secretKey) {\n    checkArrayTypes(secretKey);\n    var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);\n\n    for (var i = 0; i < pk.length; i++) {\n      pk[i] = secretKey[32 + i];\n    }\n\n    return {\n      publicKey: pk,\n      secretKey: new Uint8Array(secretKey)\n    };\n  };\n\n  nacl.sign.keyPair.fromSeed = function (seed) {\n    if (seed.length !== crypto_sign_SEEDBYTES) throw new Error('bad seed size');\n    var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);\n    var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);\n\n    for (var i = 0; i < 32; i++) {\n      sk[i] = seed[i];\n    }\n\n    crypto_sign_keypair(pk, sk, true);\n    return {\n      publicKey: pk,\n      secretKey: sk\n    };\n  };\n\n  nacl.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;\n  nacl.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;\n  nacl.sign.seedLength = crypto_sign_SEEDBYTES;\n  nacl.sign.signatureLength = crypto_sign_BYTES;\n\n  nacl.hash = function (msg) {\n    checkArrayTypes(msg);\n    var h = new Uint8Array(crypto_hash_BYTES);\n    crypto_hash(h, msg, msg.length);\n    return h;\n  };\n\n  nacl.hash.hashLength = crypto_hash_BYTES;\n\n  nacl.verify = function (x, y) {\n    checkArrayTypes(x, y);\n    if (x.length === 0 || y.length === 0) return false;\n    if (x.length !== y.length) return false;\n    return vn(x, 0, y, 0, x.length) === 0 ? true : false;\n  };\n\n  nacl.setPRNG = function (fn) {\n    randombytes = fn;\n  };\n\n  (function () {\n    var crypto = typeof self !== 'undefined' ? self.crypto || self.msCrypto : null;\n\n    if (crypto && crypto.getRandomValues) {\n      var QUOTA = 65536;\n      nacl.setPRNG(function (x, n) {\n        var i,\n            v = new Uint8Array(n);\n\n        for (i = 0; i < n; i += QUOTA) {\n          crypto.getRandomValues(v.subarray(i, i + Math.min(n - i, QUOTA)));\n        }\n\n        for (i = 0; i < n; i++) {\n          x[i] = v[i];\n        }\n\n        cleanup(v);\n      });\n    } else if (typeof require !== 'undefined') {\n      nacl.setPRNG(function (x, n) {\n        var words = [];\n\n        var r = function r(m_w) {\n          var m_w = m_w;\n          var m_z = 0x3ade68b1;\n          var mask = 0xffffffff;\n          return function () {\n            m_z = 0x9069 * (m_z & 0xFFFF) + (m_z >> 0x10) & mask;\n            m_w = 0x4650 * (m_w & 0xFFFF) + (m_w >> 0x10) & mask;\n            var result = (m_z << 0x10) + m_w & mask;\n            result /= 0x100000000;\n            result += 0.5;\n            return result * (Math.random() > .5 ? 1 : -1);\n          };\n        };\n\n        for (var i = 0, rcache; i < n; i += 4) {\n          var _r = r((rcache || Math.random()) * 0x100000000);\n\n          rcache = _r() * 0x3ade67b7;\n          words.push(_r() * 0x100000000 | 0);\n        }\n\n        var i,\n            v = words;\n\n        for (i = 0; i < n; i++) {\n          x[i] = v[i];\n        }\n\n        cleanup(v);\n      });\n    }\n  })();\n})(typeof module !== 'undefined' && module.exports ? module.exports : self.nacl = self.nacl || {});","map":null,"metadata":{},"sourceType":"script"}