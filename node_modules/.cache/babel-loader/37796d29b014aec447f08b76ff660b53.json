{"ast":null,"code":"/*\n* Copyright (c) 2010-2011 Intalio Pte, All Rights Reserved (https://github.com/cheongwy/node-scrypt-js)\n* Copyright (c) 2013 Joey Hewitt\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in\n* all copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n* THE SOFTWARE.\n*/\n(function (exports) {\n  \"use strict\";\n\n  var MAX_VALUE = 2147483647;\n  var workerUrl = null; //function scrypt(byte[] passwd, byte[] salt, int N, int r, int p, int dkLen)\n\n  /*\n   * N = Cpu cost\n   * r = Memory cost\n   * p = parallelization cost\n   *\n   */\n\n  exports.Crypto_scrypt = function (passwd, salt, N, r, p, dkLen, callback, maxThreads) {\n    if (N == 0 || (N & N - 1) != 0) throw new Error(\"N must be > 0 and a power of 2\");\n    if (N > MAX_VALUE / 128 / r) throw new Error(\"Parameter N is too large\");\n    if (r > MAX_VALUE / 128 / p) throw new Error(\"Parameter r is too large\");\n    var PBKDF2_opts = {\n      iterations: 1,\n      hasher: exports.Crypto.SHA256,\n      asBytes: true\n    };\n    var B = exports.Crypto.PBKDF2(passwd, salt, p * 128 * r, PBKDF2_opts);\n\n    try {\n      var workerI = 0;\n      var worksDone = 0;\n\n      var makeWorker = function makeWorker() {\n        if (!workerUrl) {\n          var code = '(' + scryptCore.toString() + ')()';\n          var blob;\n\n          try {\n            blob = new Blob([code], {\n              type: \"text/javascript\"\n            });\n          } catch (e) {\n            window.BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;\n            blob = new BlobBuilder();\n            blob.append(code);\n            blob = blob.getBlob(\"text/javascript\");\n          }\n\n          workerUrl = URL.createObjectURL(blob);\n        }\n\n        var worker = new Worker(workerUrl);\n\n        worker.onmessage = function (event) {\n          var Bi = event.data[0],\n              Bslice = event.data[1];\n\n          if (workerI < p) {\n            worker.postMessage([N, r, p, B, workerI++]);\n          }\n\n          var length = Bslice.length,\n              destPos = Bi * 128 * r,\n              srcPos = 0;\n\n          while (length--) {\n            B[destPos++] = Bslice[srcPos++];\n          }\n\n          if (++worksDone == p) {\n            callback(exports.Crypto.PBKDF2(passwd, B, dkLen, PBKDF2_opts));\n          }\n        };\n\n        return worker;\n      };\n\n      for (var threadN = Math.min(maxThreads || 2, p); threadN > 0; threadN--) {\n        makeWorker().postMessage([N, r, p, B, workerI++]);\n      }\n    } catch (e) {\n      setTimeout(function () {\n        scryptCore();\n        callback(exports.Crypto.PBKDF2(passwd, B, dkLen, PBKDF2_opts));\n      }, 0);\n    } // using this function to enclose everything needed to create a worker (but also invokable directly for synchronous use)\n\n\n    function scryptCore() {\n      var XY, V;\n\n      if (typeof B === 'undefined') {\n        onmessage = function onmessage(event) {\n          var data = event.data;\n          var N = data[0],\n              r = data[1],\n              p = data[2],\n              B = data[3],\n              i = data[4];\n\n          if (!XY) {\n            alloc(r, N);\n          }\n\n          var Bslice = [];\n          arraycopy32(B, i * 128 * r, Bslice, 0, 128 * r);\n          smix(Bslice, 0, r, N, V, XY);\n          postMessage([i, Bslice]);\n        };\n      } else {\n        if (!XY) {\n          alloc(r, N);\n        }\n\n        for (var i = 0; i < p; i++) {\n          smix(B, i * 128 * r, r, N, V, XY);\n        }\n      }\n\n      function alloc(r, N) {\n        try {\n          if (navigator.userAgent.match(/Chrome/)) {\n            // with Uint8Array, unit tests go almost a second faster in Chrome, but 2x slower in Firefox... ?\n            XY = new Uint8Array(256 * r);\n            V = new Uint8Array(128 * r * N);\n          } else {\n            throw \"use standard arrays\";\n          }\n        } catch (e) {\n          XY = [], V = [];\n        }\n      }\n\n      function smix(B, Bi, r, N, V, XY) {\n        var Xi = 0;\n        var Yi = 128 * r;\n        var i;\n        arraycopy32(B, Bi, XY, Xi, Yi);\n\n        for (i = 0; i < N; i++) {\n          arraycopy32(XY, Xi, V, i * Yi, Yi);\n          blockmix_salsa8(XY, Xi, Yi, r);\n        }\n\n        for (i = 0; i < N; i++) {\n          var j = integerify(XY, Xi, r) & N - 1;\n          blockxor(V, j * Yi, XY, Xi, Yi);\n          blockmix_salsa8(XY, Xi, Yi, r);\n        }\n\n        arraycopy32(XY, Xi, B, Bi, Yi);\n      }\n\n      function blockmix_salsa8(BY, Bi, Yi, r) {\n        var X = [];\n        var i;\n        arraycopy32(BY, Bi + (2 * r - 1) * 64, X, 0, 64);\n\n        for (i = 0; i < 2 * r; i++) {\n          blockxor(BY, i * 64, X, 0, 64);\n          salsa20_8(X);\n          arraycopy32(X, 0, BY, Yi + i * 64, 64);\n        }\n\n        for (i = 0; i < r; i++) {\n          arraycopy32(BY, Yi + i * 2 * 64, BY, Bi + i * 64, 64);\n        }\n\n        for (i = 0; i < r; i++) {\n          arraycopy32(BY, Yi + (i * 2 + 1) * 64, BY, Bi + (i + r) * 64, 64);\n        }\n      }\n\n      function R(a, b) {\n        return a << b | a >>> 32 - b;\n      }\n\n      function salsa20_8(B) {\n        var B32 = new Array(32);\n        var x = new Array(32);\n        var i;\n\n        for (i = 0; i < 16; i++) {\n          B32[i] = (B[i * 4 + 0] & 0xff) << 0;\n          B32[i] |= (B[i * 4 + 1] & 0xff) << 8;\n          B32[i] |= (B[i * 4 + 2] & 0xff) << 16;\n          B32[i] |= (B[i * 4 + 3] & 0xff) << 24;\n        }\n\n        arraycopy(B32, 0, x, 0, 16);\n\n        for (i = 8; i > 0; i -= 2) {\n          x[4] ^= R(x[0] + x[12], 7);\n          x[8] ^= R(x[4] + x[0], 9);\n          x[12] ^= R(x[8] + x[4], 13);\n          x[0] ^= R(x[12] + x[8], 18);\n          x[9] ^= R(x[5] + x[1], 7);\n          x[13] ^= R(x[9] + x[5], 9);\n          x[1] ^= R(x[13] + x[9], 13);\n          x[5] ^= R(x[1] + x[13], 18);\n          x[14] ^= R(x[10] + x[6], 7);\n          x[2] ^= R(x[14] + x[10], 9);\n          x[6] ^= R(x[2] + x[14], 13);\n          x[10] ^= R(x[6] + x[2], 18);\n          x[3] ^= R(x[15] + x[11], 7);\n          x[7] ^= R(x[3] + x[15], 9);\n          x[11] ^= R(x[7] + x[3], 13);\n          x[15] ^= R(x[11] + x[7], 18);\n          x[1] ^= R(x[0] + x[3], 7);\n          x[2] ^= R(x[1] + x[0], 9);\n          x[3] ^= R(x[2] + x[1], 13);\n          x[0] ^= R(x[3] + x[2], 18);\n          x[6] ^= R(x[5] + x[4], 7);\n          x[7] ^= R(x[6] + x[5], 9);\n          x[4] ^= R(x[7] + x[6], 13);\n          x[5] ^= R(x[4] + x[7], 18);\n          x[11] ^= R(x[10] + x[9], 7);\n          x[8] ^= R(x[11] + x[10], 9);\n          x[9] ^= R(x[8] + x[11], 13);\n          x[10] ^= R(x[9] + x[8], 18);\n          x[12] ^= R(x[15] + x[14], 7);\n          x[13] ^= R(x[12] + x[15], 9);\n          x[14] ^= R(x[13] + x[12], 13);\n          x[15] ^= R(x[14] + x[13], 18);\n        }\n\n        for (i = 0; i < 16; ++i) {\n          B32[i] = x[i] + B32[i];\n        }\n\n        for (i = 0; i < 16; i++) {\n          var bi = i * 4;\n          B[bi + 0] = B32[i] >> 0 & 0xff;\n          B[bi + 1] = B32[i] >> 8 & 0xff;\n          B[bi + 2] = B32[i] >> 16 & 0xff;\n          B[bi + 3] = B32[i] >> 24 & 0xff;\n        }\n      }\n\n      function blockxor(S, Si, D, Di, len) {\n        var i = len >> 6;\n\n        while (i--) {\n          D[Di++] ^= S[Si++];\n          D[Di++] ^= S[Si++];\n          D[Di++] ^= S[Si++];\n          D[Di++] ^= S[Si++];\n          D[Di++] ^= S[Si++];\n          D[Di++] ^= S[Si++];\n          D[Di++] ^= S[Si++];\n          D[Di++] ^= S[Si++];\n          D[Di++] ^= S[Si++];\n          D[Di++] ^= S[Si++];\n          D[Di++] ^= S[Si++];\n          D[Di++] ^= S[Si++];\n          D[Di++] ^= S[Si++];\n          D[Di++] ^= S[Si++];\n          D[Di++] ^= S[Si++];\n          D[Di++] ^= S[Si++];\n          D[Di++] ^= S[Si++];\n          D[Di++] ^= S[Si++];\n          D[Di++] ^= S[Si++];\n          D[Di++] ^= S[Si++];\n          D[Di++] ^= S[Si++];\n          D[Di++] ^= S[Si++];\n          D[Di++] ^= S[Si++];\n          D[Di++] ^= S[Si++];\n          D[Di++] ^= S[Si++];\n          D[Di++] ^= S[Si++];\n          D[Di++] ^= S[Si++];\n          D[Di++] ^= S[Si++];\n          D[Di++] ^= S[Si++];\n          D[Di++] ^= S[Si++];\n          D[Di++] ^= S[Si++];\n          D[Di++] ^= S[Si++];\n          D[Di++] ^= S[Si++];\n          D[Di++] ^= S[Si++];\n          D[Di++] ^= S[Si++];\n          D[Di++] ^= S[Si++];\n          D[Di++] ^= S[Si++];\n          D[Di++] ^= S[Si++];\n          D[Di++] ^= S[Si++];\n          D[Di++] ^= S[Si++];\n          D[Di++] ^= S[Si++];\n          D[Di++] ^= S[Si++];\n          D[Di++] ^= S[Si++];\n          D[Di++] ^= S[Si++];\n          D[Di++] ^= S[Si++];\n          D[Di++] ^= S[Si++];\n          D[Di++] ^= S[Si++];\n          D[Di++] ^= S[Si++];\n          D[Di++] ^= S[Si++];\n          D[Di++] ^= S[Si++];\n          D[Di++] ^= S[Si++];\n          D[Di++] ^= S[Si++];\n          D[Di++] ^= S[Si++];\n          D[Di++] ^= S[Si++];\n          D[Di++] ^= S[Si++];\n          D[Di++] ^= S[Si++];\n          D[Di++] ^= S[Si++];\n          D[Di++] ^= S[Si++];\n          D[Di++] ^= S[Si++];\n          D[Di++] ^= S[Si++];\n          D[Di++] ^= S[Si++];\n          D[Di++] ^= S[Si++];\n          D[Di++] ^= S[Si++];\n          D[Di++] ^= S[Si++];\n        }\n      }\n\n      function integerify(B, bi, r) {\n        var n;\n        bi += (2 * r - 1) * 64;\n        n = (B[bi + 0] & 0xff) << 0;\n        n |= (B[bi + 1] & 0xff) << 8;\n        n |= (B[bi + 2] & 0xff) << 16;\n        n |= (B[bi + 3] & 0xff) << 24;\n        return n;\n      }\n\n      function arraycopy(src, srcPos, dest, destPos, length) {\n        while (length--) {\n          dest[destPos++] = src[srcPos++];\n        }\n      }\n\n      function arraycopy32(src, srcPos, dest, destPos, length) {\n        var i = length >> 5;\n\n        while (i--) {\n          dest[destPos++] = src[srcPos++];\n          dest[destPos++] = src[srcPos++];\n          dest[destPos++] = src[srcPos++];\n          dest[destPos++] = src[srcPos++];\n          dest[destPos++] = src[srcPos++];\n          dest[destPos++] = src[srcPos++];\n          dest[destPos++] = src[srcPos++];\n          dest[destPos++] = src[srcPos++];\n          dest[destPos++] = src[srcPos++];\n          dest[destPos++] = src[srcPos++];\n          dest[destPos++] = src[srcPos++];\n          dest[destPos++] = src[srcPos++];\n          dest[destPos++] = src[srcPos++];\n          dest[destPos++] = src[srcPos++];\n          dest[destPos++] = src[srcPos++];\n          dest[destPos++] = src[srcPos++];\n          dest[destPos++] = src[srcPos++];\n          dest[destPos++] = src[srcPos++];\n          dest[destPos++] = src[srcPos++];\n          dest[destPos++] = src[srcPos++];\n          dest[destPos++] = src[srcPos++];\n          dest[destPos++] = src[srcPos++];\n          dest[destPos++] = src[srcPos++];\n          dest[destPos++] = src[srcPos++];\n          dest[destPos++] = src[srcPos++];\n          dest[destPos++] = src[srcPos++];\n          dest[destPos++] = src[srcPos++];\n          dest[destPos++] = src[srcPos++];\n          dest[destPos++] = src[srcPos++];\n          dest[destPos++] = src[srcPos++];\n          dest[destPos++] = src[srcPos++];\n          dest[destPos++] = src[srcPos++];\n        }\n      }\n    } // scryptCore\n\n  }; // Crypto_scrypt\n\n  /*\n   * Crypto-JS v2.5.4\n   * http://code.google.com/p/crypto-js/\n   * (c) 2009-2012 by Jeff Mott. All rights reserved.\n   * http://code.google.com/p/crypto-js/wiki/License\n   */\n\n\n  (typeof Crypto == \"undefined\" || !Crypto.util) && function () {\n    var d = exports.Crypto = {},\n        k = d.util = {\n      rotl: function rotl(b, a) {\n        return b << a | b >>> 32 - a;\n      },\n      rotr: function rotr(b, a) {\n        return b << 32 - a | b >>> a;\n      },\n      endian: function endian(b) {\n        if (b.constructor == Number) return k.rotl(b, 8) & 16711935 | k.rotl(b, 24) & 4278255360;\n\n        for (var a = 0; a < b.length; a++) {\n          b[a] = k.endian(b[a]);\n        }\n\n        return b;\n      },\n      randomBytes: function randomBytes(b) {\n        for (var a = []; b > 0; b--) {\n          a.push(Math.floor(Math.random() * 256));\n        }\n\n        return a;\n      },\n      bytesToWords: function bytesToWords(b) {\n        for (var a = [], c = 0, e = 0; c < b.length; c++, e += 8) {\n          a[e >>> 5] |= (b[c] & 255) << 24 - e % 32;\n        }\n\n        return a;\n      },\n      wordsToBytes: function wordsToBytes(b) {\n        for (var a = [], c = 0; c < b.length * 32; c += 8) {\n          a.push(b[c >>> 5] >>> 24 - c % 32 & 255);\n        }\n\n        return a;\n      },\n      bytesToHex: function bytesToHex(b) {\n        for (var a = [], c = 0; c < b.length; c++) {\n          a.push((b[c] >>> 4).toString(16)), a.push((b[c] & 15).toString(16));\n        }\n\n        return a.join(\"\");\n      },\n      hexToBytes: function hexToBytes(b) {\n        for (var a = [], c = 0; c < b.length; c += 2) {\n          a.push(parseInt(b.substr(c, 2), 16));\n        }\n\n        return a;\n      },\n      bytesToBase64: function bytesToBase64(b) {\n        for (var a = [], c = 0; c < b.length; c += 3) {\n          for (var e = b[c] << 16 | b[c + 1] << 8 | b[c + 2], t = 0; t < 4; t++) {\n            c * 8 + t * 6 <= b.length * 8 ? a.push(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".charAt(e >>> 6 * (3 - t) & 63)) : a.push(\"=\");\n          }\n        }\n\n        return a.join(\"\");\n      },\n      base64ToBytes: function base64ToBytes(b) {\n        for (var b = b.replace(/[^A-Z0-9+\\/]/ig, \"\"), a = [], c = 0, e = 0; c < b.length; e = ++c % 4) {\n          e != 0 && a.push((\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".indexOf(b.charAt(c - 1)) & Math.pow(2, -2 * e + 8) - 1) << e * 2 | \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".indexOf(b.charAt(c)) >>> 6 - e * 2);\n        }\n\n        return a;\n      }\n    },\n        d = d.charenc = {};\n    d.UTF8 = {\n      stringToBytes: function stringToBytes(b) {\n        return f.stringToBytes(unescape(encodeURIComponent(b)));\n      },\n      bytesToString: function bytesToString(b) {\n        return decodeURIComponent(escape(f.bytesToString(b)));\n      }\n    };\n    var f = d.Binary = {\n      stringToBytes: function stringToBytes(b) {\n        for (var a = [], c = 0; c < b.length; c++) {\n          a.push(b.charCodeAt(c) & 255);\n        }\n\n        return a;\n      },\n      bytesToString: function bytesToString(b) {\n        for (var a = [], c = 0; c < b.length; c++) {\n          a.push(String.fromCharCode(b[c]));\n        }\n\n        return a.join(\"\");\n      }\n    };\n  }();\n\n  (function () {\n    var d = exports.Crypto,\n        k = d.util,\n        f = d.charenc,\n        b = f.UTF8,\n        a = f.Binary,\n        c = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298],\n        e = d.SHA256 = function (b, c) {\n      var g = k.wordsToBytes(e._sha256(b));\n      return c && c.asBytes ? g : c && c.asString ? a.bytesToString(g) : k.bytesToHex(g);\n    };\n\n    e._sha256 = function (a) {\n      a.constructor == String && (a = b.stringToBytes(a));\n      var e = k.bytesToWords(a),\n          g = a.length * 8,\n          a = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225],\n          d = [],\n          f,\n          i,\n          r,\n          h,\n          m,\n          q,\n          n,\n          u,\n          j,\n          o,\n          l;\n      e[g >> 5] |= 128 << 24 - g % 32;\n      e[(g + 64 >> 9 << 4) + 15] = g;\n\n      for (u = 0; u < e.length; u += 16) {\n        g = a[0];\n        f = a[1];\n        i = a[2];\n        r = a[3];\n        h = a[4];\n        m = a[5];\n        q = a[6];\n        n = a[7];\n\n        for (j = 0; j < 64; j++) {\n          j < 16 ? d[j] = e[j + u] : (o = d[j - 15], l = d[j - 2], d[j] = ((o << 25 | o >>> 7) ^ (o << 14 | o >>> 18) ^ o >>> 3) + (d[j - 7] >>> 0) + ((l << 15 | l >>> 17) ^ (l << 13 | l >>> 19) ^ l >>> 10) + (d[j - 16] >>> 0));\n          l = g & f ^ g & i ^ f & i;\n          var w = (g << 30 | g >>> 2) ^ (g << 19 | g >>> 13) ^ (g << 10 | g >>> 22);\n          o = (n >>> 0) + ((h << 26 | h >>> 6) ^ (h << 21 | h >>> 11) ^ (h << 7 | h >>> 25)) + (h & m ^ ~h & q) + c[j] + (d[j] >>> 0);\n          l = w + l;\n          n = q;\n          q = m;\n          m = h;\n          h = r + o >>> 0;\n          r = i;\n          i = f;\n          f = g;\n          g = o + l >>> 0;\n        }\n\n        a[0] += g;\n        a[1] += f;\n        a[2] += i;\n        a[3] += r;\n        a[4] += h;\n        a[5] += m;\n        a[6] += q;\n        a[7] += n;\n      }\n\n      return a;\n    };\n\n    e._blocksize = 16;\n    e._digestsize = 32;\n  })();\n\n  (function () {\n    var d = exports.Crypto,\n        k = d.util,\n        f = d.charenc,\n        b = f.UTF8,\n        a = f.Binary;\n\n    d.HMAC = function (c, e, d, f) {\n      e.constructor == String && (e = b.stringToBytes(e));\n      d.constructor == String && (d = b.stringToBytes(d));\n      d.length > c._blocksize * 4 && (d = c(d, {\n        asBytes: !0\n      }));\n\n      for (var g = d.slice(0), d = d.slice(0), s = 0; s < c._blocksize * 4; s++) {\n        g[s] ^= 92, d[s] ^= 54;\n      }\n\n      c = c(g.concat(c(d.concat(e), {\n        asBytes: !0\n      })), {\n        asBytes: !0\n      });\n      return f && f.asBytes ? c : f && f.asString ? a.bytesToString(c) : k.bytesToHex(c);\n    };\n  })();\n\n  (function () {\n    var d = exports.Crypto,\n        k = d.util,\n        f = d.charenc,\n        b = f.UTF8,\n        a = f.Binary;\n\n    d.PBKDF2 = function (c, e, f, p) {\n      function g(a, b) {\n        return d.HMAC(s, b, a, {\n          asBytes: !0\n        });\n      }\n\n      c.constructor == String && (c = b.stringToBytes(c));\n      e.constructor == String && (e = b.stringToBytes(e));\n\n      for (var s = p && p.hasher || d.SHA1, v = p && p.iterations || 1, i = [], r = 1; i.length < f;) {\n        for (var h = g(c, e.concat(k.wordsToBytes([r]))), m = h, q = 1; q < v; q++) {\n          for (var m = g(c, m), n = 0; n < h.length; n++) {\n            h[n] ^= m[n];\n          }\n        }\n\n        i = i.concat(h);\n        r++;\n      }\n\n      i.length = f;\n      return p && p.asBytes ? i : p && p.asString ? a.bytesToString(i) : k.bytesToHex(i);\n    };\n  })();\n})(typeof exports != 'undefined' ? exports : window);","map":null,"metadata":{},"sourceType":"script"}