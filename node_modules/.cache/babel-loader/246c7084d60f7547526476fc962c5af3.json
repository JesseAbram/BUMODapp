{"ast":null,"code":"\"use strict\";\n\nvar sjcl = {\n  cipher: {},\n  hash: {},\n  keyexchange: {},\n  mode: {},\n  misc: {},\n  codec: {},\n  exception: {\n    corrupt: function corrupt(message) {\n      this.toString = function () {\n        return \"CORRUPT: \" + this.message;\n      };\n\n      this.message = message;\n    },\n    invalid: function invalid(message) {\n      this.toString = function () {\n        return \"INVALID: \" + this.message;\n      };\n\n      this.message = message;\n    },\n    bug: function bug(message) {\n      this.toString = function () {\n        return \"BUG: \" + this.message;\n      };\n\n      this.message = message;\n    },\n    notReady: function notReady(message) {\n      this.toString = function () {\n        return \"NOT READY: \" + this.message;\n      };\n\n      this.message = message;\n    }\n  }\n};\n\nif (typeof module != \"undefined\" && module.exports) {\n  module.exports = sjcl;\n}\n\nsjcl.cipher.aes = function (key) {\n  if (!this._tables[0][0][0]) {\n    this._precompute();\n  }\n\n  var i,\n      j,\n      tmp,\n      encKey,\n      decKey,\n      sbox = this._tables[0][4],\n      decTable = this._tables[1],\n      keyLen = key.length,\n      rcon = 1;\n\n  if (keyLen !== 4 && keyLen !== 6 && keyLen !== 8) {\n    throw new sjcl.exception.invalid(\"invalid aes key size\");\n  }\n\n  this._key = [encKey = key.slice(0), decKey = []];\n\n  for (i = keyLen; i < 4 * keyLen + 28; i++) {\n    tmp = encKey[i - 1];\n\n    if (i % keyLen === 0 || keyLen === 8 && i % keyLen === 4) {\n      tmp = sbox[tmp >>> 24] << 24 ^ sbox[tmp >> 16 & 255] << 16 ^ sbox[tmp >> 8 & 255] << 8 ^ sbox[tmp & 255];\n\n      if (i % keyLen === 0) {\n        tmp = tmp << 8 ^ tmp >>> 24 ^ rcon << 24;\n        rcon = rcon << 1 ^ (rcon >> 7) * 283;\n      }\n    }\n\n    encKey[i] = encKey[i - keyLen] ^ tmp;\n  }\n\n  for (j = 0; i; j++, i--) {\n    tmp = encKey[j & 3 ? i : i - 4];\n\n    if (i <= 4 || j < 4) {\n      decKey[j] = tmp;\n    } else {\n      decKey[j] = decTable[0][sbox[tmp >>> 24]] ^ decTable[1][sbox[tmp >> 16 & 255]] ^ decTable[2][sbox[tmp >> 8 & 255]] ^ decTable[3][sbox[tmp & 255]];\n    }\n  }\n};\n\nsjcl.cipher.aes.prototype = {\n  encrypt: function encrypt(data) {\n    return this._crypt(data, 0);\n  },\n  decrypt: function decrypt(data) {\n    return this._crypt(data, 1);\n  },\n  _tables: [[[], [], [], [], []], [[], [], [], [], []]],\n  _precompute: function _precompute() {\n    var encTable = this._tables[0],\n        decTable = this._tables[1],\n        sbox = encTable[4],\n        sboxInv = decTable[4],\n        i,\n        x,\n        xInv,\n        d = [],\n        th = [],\n        x2,\n        x4,\n        x8,\n        s,\n        tEnc,\n        tDec;\n\n    for (i = 0; i < 256; i++) {\n      th[(d[i] = i << 1 ^ (i >> 7) * 283) ^ i] = i;\n    }\n\n    for (x = xInv = 0; !sbox[x]; x ^= x2 || 1, xInv = th[xInv] || 1) {\n      s = xInv ^ xInv << 1 ^ xInv << 2 ^ xInv << 3 ^ xInv << 4;\n      s = s >> 8 ^ s & 255 ^ 99;\n      sbox[x] = s;\n      sboxInv[s] = x;\n      x8 = d[x4 = d[x2 = d[x]]];\n      tDec = x8 * 0x1010101 ^ x4 * 0x10001 ^ x2 * 0x101 ^ x * 0x1010100;\n      tEnc = d[s] * 0x101 ^ s * 0x1010100;\n\n      for (i = 0; i < 4; i++) {\n        encTable[i][x] = tEnc = tEnc << 24 ^ tEnc >>> 8;\n        decTable[i][s] = tDec = tDec << 24 ^ tDec >>> 8;\n      }\n    }\n\n    for (i = 0; i < 5; i++) {\n      encTable[i] = encTable[i].slice(0);\n      decTable[i] = decTable[i].slice(0);\n    }\n  },\n  _crypt: function _crypt(input, dir) {\n    if (input.length !== 4) {\n      throw new sjcl.exception.invalid(\"invalid aes block size\");\n    }\n\n    var key = this._key[dir],\n        a = input[0] ^ key[0],\n        b = input[dir ? 3 : 1] ^ key[1],\n        c = input[2] ^ key[2],\n        d = input[dir ? 1 : 3] ^ key[3],\n        a2,\n        b2,\n        c2,\n        nInnerRounds = key.length / 4 - 2,\n        i,\n        kIndex = 4,\n        out = [0, 0, 0, 0],\n        table = this._tables[dir],\n        t0 = table[0],\n        t1 = table[1],\n        t2 = table[2],\n        t3 = table[3],\n        sbox = table[4];\n\n    for (i = 0; i < nInnerRounds; i++) {\n      a2 = t0[a >>> 24] ^ t1[b >> 16 & 255] ^ t2[c >> 8 & 255] ^ t3[d & 255] ^ key[kIndex];\n      b2 = t0[b >>> 24] ^ t1[c >> 16 & 255] ^ t2[d >> 8 & 255] ^ t3[a & 255] ^ key[kIndex + 1];\n      c2 = t0[c >>> 24] ^ t1[d >> 16 & 255] ^ t2[a >> 8 & 255] ^ t3[b & 255] ^ key[kIndex + 2];\n      d = t0[d >>> 24] ^ t1[a >> 16 & 255] ^ t2[b >> 8 & 255] ^ t3[c & 255] ^ key[kIndex + 3];\n      kIndex += 4;\n      a = a2;\n      b = b2;\n      c = c2;\n    }\n\n    for (i = 0; i < 4; i++) {\n      out[dir ? 3 & -i : i] = sbox[a >>> 24] << 24 ^ sbox[b >> 16 & 255] << 16 ^ sbox[c >> 8 & 255] << 8 ^ sbox[d & 255] ^ key[kIndex++];\n      a2 = a;\n      a = b;\n      b = c;\n      c = d;\n      d = a2;\n    }\n\n    return out;\n  }\n};\nsjcl.bitArray = {\n  bitSlice: function bitSlice(a, bstart, bend) {\n    a = sjcl.bitArray._shiftRight(a.slice(bstart / 32), 32 - (bstart & 31)).slice(1);\n    return bend === undefined ? a : sjcl.bitArray.clamp(a, bend - bstart);\n  },\n  extract: function extract(a, bstart, blength) {\n    var x,\n        sh = Math.floor(-bstart - blength & 31);\n\n    if ((bstart + blength - 1 ^ bstart) & -32) {\n      x = a[bstart / 32 | 0] << 32 - sh ^ a[bstart / 32 + 1 | 0] >>> sh;\n    } else {\n      x = a[bstart / 32 | 0] >>> sh;\n    }\n\n    return x & (1 << blength) - 1;\n  },\n  concat: function concat(a1, a2) {\n    if (a1.length === 0 || a2.length === 0) {\n      return a1.concat(a2);\n    }\n\n    var out,\n        i,\n        last = a1[a1.length - 1],\n        shift = sjcl.bitArray.getPartial(last);\n\n    if (shift === 32) {\n      return a1.concat(a2);\n    } else {\n      return sjcl.bitArray._shiftRight(a2, shift, last | 0, a1.slice(0, a1.length - 1));\n    }\n  },\n  bitLength: function bitLength(a) {\n    var l = a.length,\n        x;\n\n    if (l === 0) {\n      return 0;\n    }\n\n    x = a[l - 1];\n    return (l - 1) * 32 + sjcl.bitArray.getPartial(x);\n  },\n  clamp: function clamp(a, len) {\n    if (a.length * 32 < len) {\n      return a;\n    }\n\n    a = a.slice(0, Math.ceil(len / 32));\n    var l = a.length;\n    len = len & 31;\n\n    if (l > 0 && len) {\n      a[l - 1] = sjcl.bitArray.partial(len, a[l - 1] & 0x80000000 >> len - 1, 1);\n    }\n\n    return a;\n  },\n  partial: function partial(len, x, _end) {\n    if (len === 32) {\n      return x;\n    }\n\n    return (_end ? x | 0 : x << 32 - len) + len * 0x10000000000;\n  },\n  getPartial: function getPartial(x) {\n    return Math.round(x / 0x10000000000) || 32;\n  },\n  equal: function equal(a, b) {\n    if (sjcl.bitArray.bitLength(a) !== sjcl.bitArray.bitLength(b)) {\n      return false;\n    }\n\n    var x = 0,\n        i;\n\n    for (i = 0; i < a.length; i++) {\n      x |= a[i] ^ b[i];\n    }\n\n    return x === 0;\n  },\n  _shiftRight: function _shiftRight(a, shift, carry, out) {\n    var i,\n        last2 = 0,\n        shift2;\n\n    if (out === undefined) {\n      out = [];\n    }\n\n    for (; shift >= 32; shift -= 32) {\n      out.push(carry);\n      carry = 0;\n    }\n\n    if (shift === 0) {\n      return out.concat(a);\n    }\n\n    for (i = 0; i < a.length; i++) {\n      out.push(carry | a[i] >>> shift);\n      carry = a[i] << 32 - shift;\n    }\n\n    last2 = a.length ? a[a.length - 1] : 0;\n    shift2 = sjcl.bitArray.getPartial(last2);\n    out.push(sjcl.bitArray.partial(shift + shift2 & 31, shift + shift2 > 32 ? carry : out.pop(), 1));\n    return out;\n  },\n  _xor4: function _xor4(x, y) {\n    return [x[0] ^ y[0], x[1] ^ y[1], x[2] ^ y[2], x[3] ^ y[3]];\n  }\n};\nsjcl.codec.utf8String = {\n  fromBits: function fromBits(arr) {\n    var out = \"\",\n        bl = sjcl.bitArray.bitLength(arr),\n        i,\n        tmp;\n\n    for (i = 0; i < bl / 8; i++) {\n      if ((i & 3) === 0) {\n        tmp = arr[i / 4];\n      }\n\n      out += String.fromCharCode(tmp >>> 24);\n      tmp <<= 8;\n    }\n\n    return decodeURIComponent(escape(out));\n  },\n  toBits: function toBits(str) {\n    str = unescape(encodeURIComponent(str));\n    var out = [],\n        i,\n        tmp = 0;\n\n    for (i = 0; i < str.length; i++) {\n      tmp = tmp << 8 | str.charCodeAt(i);\n\n      if ((i & 3) === 3) {\n        out.push(tmp);\n        tmp = 0;\n      }\n    }\n\n    if (i & 3) {\n      out.push(sjcl.bitArray.partial(8 * (i & 3), tmp));\n    }\n\n    return out;\n  }\n};\nsjcl.codec.hex = {\n  fromBits: function fromBits(arr) {\n    var out = \"\",\n        i,\n        x;\n\n    for (i = 0; i < arr.length; i++) {\n      out += ((arr[i] | 0) + 0xf00000000000).toString(16).substr(4);\n    }\n\n    return out.substr(0, sjcl.bitArray.bitLength(arr) / 4);\n  },\n  toBits: function toBits(str) {\n    var i,\n        out = [],\n        len;\n    str = str.replace(/\\s|0x/g, \"\");\n    len = str.length;\n    str = str + \"00000000\";\n\n    for (i = 0; i < str.length; i += 8) {\n      out.push(parseInt(str.substr(i, 8), 16) ^ 0);\n    }\n\n    return sjcl.bitArray.clamp(out, len * 4);\n  }\n};\nsjcl.codec.base64 = {\n  _chars: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\",\n  fromBits: function fromBits(arr, _noEquals, _url) {\n    var out = \"\",\n        i,\n        bits = 0,\n        c = sjcl.codec.base64._chars,\n        ta = 0,\n        bl = sjcl.bitArray.bitLength(arr);\n    if (_url) c = c.substr(0, 62) + \"-_\";\n\n    for (i = 0; out.length * 6 < bl;) {\n      out += c.charAt((ta ^ arr[i] >>> bits) >>> 26);\n\n      if (bits < 6) {\n        ta = arr[i] << 6 - bits;\n        bits += 26;\n        i++;\n      } else {\n        ta <<= 6;\n        bits -= 6;\n      }\n    }\n\n    while (out.length & 3 && !_noEquals) {\n      out += \"=\";\n    }\n\n    return out;\n  },\n  toBits: function toBits(str, _url) {\n    str = str.replace(/\\s|=/g, \"\");\n    var out = [],\n        i,\n        bits = 0,\n        c = sjcl.codec.base64._chars,\n        ta = 0,\n        x;\n    if (_url) c = c.substr(0, 62) + \"-_\";\n\n    for (i = 0; i < str.length; i++) {\n      x = c.indexOf(str.charAt(i));\n\n      if (x < 0) {\n        throw new sjcl.exception.invalid(\"this isn't base64!\");\n      }\n\n      if (bits > 26) {\n        bits -= 26;\n        out.push(ta ^ x >>> bits);\n        ta = x << 32 - bits;\n      } else {\n        bits += 6;\n        ta ^= x << 32 - bits;\n      }\n    }\n\n    if (bits & 56) {\n      out.push(sjcl.bitArray.partial(bits & 56, ta, 1));\n    }\n\n    return out;\n  }\n};\nsjcl.codec.base64url = {\n  fromBits: function fromBits(arr) {\n    return sjcl.codec.base64.fromBits(arr, 1, 1);\n  },\n  toBits: function toBits(str) {\n    return sjcl.codec.base64.toBits(str, 1);\n  }\n};\nsjcl.codec.base58 = {\n  alphabets: \"123456789AbCDEFGHJKLMNPQRSTuVWXYZaBcdefghijkmnopqrstUvwxyz\",\n  BASE: 58,\n  ALPHABET_MAP: {},\n  LEADER: \"1\",\n  encode: function encode(a) {\n    if (a.length === 0) return \"\";\n    var i, j;\n    var digits = [0];\n\n    for (i = 0; i < a.length; i++) {\n      for (j = 0; j < digits.length; j++) {\n        digits[j] <<= 8;\n      }\n\n      digits[0] += a[i];\n      var carry = 0;\n\n      for (j = 0; j < digits.length; ++j) {\n        digits[j] += carry;\n        carry = digits[j] / this.BASE | 0;\n        digits[j] %= this.BASE;\n      }\n\n      while (carry) {\n        digits.push(carry % this.BASE);\n        carry = carry / this.BASE | 0;\n      }\n    }\n\n    for (i = 0; a[i] === 0 && i < a.length - 1; i++) {\n      digits.push(0);\n    }\n\n    return digits.reverse().map(function (digit) {\n      return sjcl.codec.base58.alphabets[digit];\n    }).join(\"\");\n  },\n  decode: function decode(str) {\n    for (var i = 0; i < this.alphabets.length; i++) {\n      this.ALPHABET_MAP[this.alphabets.charAt(i)] = i;\n    }\n\n    if (str.length === 0) {\n      return [];\n    }\n\n    var i, j;\n    var bytes = [0];\n\n    for (i = 0; i < str.length; i++) {\n      var c = str[i];\n      if (!(c in this.ALPHABET_MAP)) throw new Error(\"Non-base\" + this.BASE + \" character\");\n\n      for (j = 0; j < bytes.length; j++) {\n        bytes[j] *= this.BASE;\n      }\n\n      bytes[0] += this.ALPHABET_MAP[c];\n      var carry = 0;\n\n      for (j = 0; j < bytes.length; ++j) {\n        bytes[j] += carry;\n        carry = bytes[j] >> 8;\n        bytes[j] &= 0xff;\n      }\n\n      while (carry) {\n        bytes.push(carry & 0xff);\n        carry >>= 8;\n      }\n    }\n\n    for (i = 0; str[i] === this.LEADER && i < str.length - 1; i++) {\n      bytes.push(0);\n    }\n\n    return bytes.reverse();\n  }\n};\nsjcl.codec.bytes = {\n  fromBits: function fromBits(arr) {\n    var out = [],\n        bl = sjcl.bitArray.bitLength(arr),\n        i,\n        tmp;\n\n    for (i = 0; i < bl / 8; i++) {\n      if ((i & 3) === 0) {\n        tmp = arr[i / 4];\n      }\n\n      out.push(tmp >>> 24);\n      tmp <<= 8;\n    }\n\n    return out;\n  },\n  toBits: function toBits(bytes) {\n    var out = [],\n        i,\n        tmp = 0;\n\n    for (i = 0; i < bytes.length; i++) {\n      tmp = tmp << 8 | bytes[i];\n\n      if ((i & 3) === 3) {\n        out.push(tmp);\n        tmp = 0;\n      }\n    }\n\n    if (i & 3) {\n      out.push(sjcl.bitArray.partial(8 * (i & 3), tmp));\n    }\n\n    return out;\n  }\n};\n\nsjcl.hash.sha256 = function (hash) {\n  if (!this._key[0]) {\n    this._precompute();\n  }\n\n  if (hash) {\n    this._h = hash._h.slice(0);\n    this._buffer = hash._buffer.slice(0);\n    this._length = hash._length;\n  } else {\n    this.reset();\n  }\n};\n\nsjcl.hash.sha256.hash = function (data) {\n  return new sjcl.hash.sha256().update(data).finalize();\n};\n\nsjcl.hash.sha256.prototype = {\n  blockSize: 512,\n  reset: function reset() {\n    this._h = this._init.slice(0);\n    this._buffer = [];\n    this._length = 0;\n    return this;\n  },\n  update: function update(data) {\n    if (typeof data === \"string\") {\n      data = sjcl.codec.utf8String.toBits(data);\n    }\n\n    var i,\n        b = this._buffer = sjcl.bitArray.concat(this._buffer, data),\n        ol = this._length,\n        nl = this._length = ol + sjcl.bitArray.bitLength(data);\n\n    for (i = 512 + ol & -512; i <= nl; i += 512) {\n      this._block(b.splice(0, 16));\n    }\n\n    return this;\n  },\n  finalize: function finalize() {\n    var i,\n        b = this._buffer,\n        h = this._h;\n    b = sjcl.bitArray.concat(b, [sjcl.bitArray.partial(1, 1)]);\n\n    for (i = b.length + 2; i & 15; i++) {\n      b.push(0);\n    }\n\n    b.push(Math.floor(this._length / 0x100000000));\n    b.push(this._length | 0);\n\n    while (b.length) {\n      this._block(b.splice(0, 16));\n    }\n\n    this.reset();\n    return h;\n  },\n  _init: [],\n  _key: [],\n  _precompute: function _precompute() {\n    var i = 0,\n        prime = 2,\n        factor;\n\n    function frac(x) {\n      return (x - Math.floor(x)) * 0x100000000 | 0;\n    }\n\n    outer: for (; i < 64; prime++) {\n      for (factor = 2; factor * factor <= prime; factor++) {\n        if (prime % factor === 0) {\n          continue outer;\n        }\n      }\n\n      if (i < 8) {\n        this._init[i] = frac(Math.pow(prime, 1 / 2));\n      }\n\n      this._key[i] = frac(Math.pow(prime, 1 / 3));\n      i++;\n    }\n  },\n  _block: function _block(words) {\n    var i,\n        tmp,\n        a,\n        b,\n        w = words.slice(0),\n        h = this._h,\n        k = this._key,\n        h0 = h[0],\n        h1 = h[1],\n        h2 = h[2],\n        h3 = h[3],\n        h4 = h[4],\n        h5 = h[5],\n        h6 = h[6],\n        h7 = h[7];\n\n    for (i = 0; i < 64; i++) {\n      if (i < 16) {\n        tmp = w[i];\n      } else {\n        a = w[i + 1 & 15];\n        b = w[i + 14 & 15];\n        tmp = w[i & 15] = (a >>> 7 ^ a >>> 18 ^ a >>> 3 ^ a << 25 ^ a << 14) + (b >>> 17 ^ b >>> 19 ^ b >>> 10 ^ b << 15 ^ b << 13) + w[i & 15] + w[i + 9 & 15] | 0;\n      }\n\n      tmp = tmp + h7 + (h4 >>> 6 ^ h4 >>> 11 ^ h4 >>> 25 ^ h4 << 26 ^ h4 << 21 ^ h4 << 7) + (h6 ^ h4 & (h5 ^ h6)) + k[i];\n      h7 = h6;\n      h6 = h5;\n      h5 = h4;\n      h4 = h3 + tmp | 0;\n      h3 = h2;\n      h2 = h1;\n      h1 = h0;\n      h0 = tmp + (h1 & h2 ^ h3 & (h1 ^ h2)) + (h1 >>> 2 ^ h1 >>> 13 ^ h1 >>> 22 ^ h1 << 30 ^ h1 << 19 ^ h1 << 10) | 0;\n    }\n\n    h[0] = h[0] + h0 | 0;\n    h[1] = h[1] + h1 | 0;\n    h[2] = h[2] + h2 | 0;\n    h[3] = h[3] + h3 | 0;\n    h[4] = h[4] + h4 | 0;\n    h[5] = h[5] + h5 | 0;\n    h[6] = h[6] + h6 | 0;\n    h[7] = h[7] + h7 | 0;\n  }\n};\n\nsjcl.hash.sha512 = function (hash) {\n  if (!this._key[0]) {\n    this._precompute();\n  }\n\n  if (hash) {\n    this._h = hash._h.slice(0);\n    this._buffer = hash._buffer.slice(0);\n    this._length = hash._length;\n  } else {\n    this.reset();\n  }\n};\n\nsjcl.hash.sha512.hash = function (data) {\n  return new sjcl.hash.sha512().update(data).finalize();\n};\n\nsjcl.hash.sha512.prototype = {\n  blockSize: 1024,\n  reset: function reset() {\n    this._h = this._init.slice(0);\n    this._buffer = [];\n    this._length = 0;\n    return this;\n  },\n  update: function update(data) {\n    if (typeof data === \"string\") {\n      data = sjcl.codec.utf8String.toBits(data);\n    }\n\n    var i,\n        b = this._buffer = sjcl.bitArray.concat(this._buffer, data),\n        ol = this._length,\n        nl = this._length = ol + sjcl.bitArray.bitLength(data);\n\n    for (i = 1024 + ol & -1024; i <= nl; i += 1024) {\n      this._block(b.splice(0, 32));\n    }\n\n    return this;\n  },\n  finalize: function finalize() {\n    var i,\n        b = this._buffer,\n        h = this._h;\n    b = sjcl.bitArray.concat(b, [sjcl.bitArray.partial(1, 1)]);\n\n    for (i = b.length + 4; i & 31; i++) {\n      b.push(0);\n    }\n\n    b.push(0);\n    b.push(0);\n    b.push(Math.floor(this._length / 0x100000000));\n    b.push(this._length | 0);\n\n    while (b.length) {\n      this._block(b.splice(0, 32));\n    }\n\n    this.reset();\n    return h;\n  },\n  _init: [],\n  _initr: [0xbcc908, 0xcaa73b, 0x94f82b, 0x1d36f1, 0xe682d1, 0x3e6c1f, 0x41bd6b, 0x7e2179],\n  _key: [],\n  _keyr: [0x28ae22, 0xef65cd, 0x4d3b2f, 0x89dbbc, 0x48b538, 0x05d019, 0x194f9b, 0x6d8118, 0x030242, 0x706fbe, 0xe4b28c, 0xffb4e2, 0x7b896f, 0x1696b1, 0xc71235, 0x692694, 0xf14ad2, 0x4f25e3, 0x8cd5b5, 0xac9c65, 0x2b0275, 0xa6e483, 0x41fbd4, 0x1153b5, 0x66dfab, 0xb43210, 0xfb213f, 0xef0ee4, 0xa88fc2, 0x0aa725, 0x03826f, 0x0e6e70, 0xd22ffc, 0x26c926, 0xc42aed, 0x95b3df, 0xaf63de, 0x77b2a8, 0xedaee6, 0x82353b, 0xf10364, 0x423001, 0xf89791, 0x54be30, 0xef5218, 0x65a910, 0x71202a, 0xbbd1b8, 0xd2d0c8, 0x41ab53, 0x8eeb99, 0x9b48a8, 0xc95a63, 0x418acb, 0x63e373, 0xb2b8a3, 0xefb2fc, 0x172f60, 0xf0ab72, 0x6439ec, 0x631e28, 0x82bde9, 0xc67915, 0x72532b, 0x26619c, 0xc0c207, 0xe0eb1e, 0x6ed178, 0x176fba, 0xc898a6, 0xf90dae, 0x1c471b, 0x047d84, 0xc72493, 0xc9bebc, 0x100d4c, 0x3e42b6, 0x657e2a, 0xd6faec, 0x475817],\n  _precompute: function _precompute() {\n    var i = 0,\n        prime = 2,\n        factor;\n\n    function frac(x) {\n      return (x - Math.floor(x)) * 0x100000000 | 0;\n    }\n\n    function frac2(x) {\n      return (x - Math.floor(x)) * 0x10000000000 & 0xff;\n    }\n\n    outer: for (; i < 80; prime++) {\n      for (factor = 2; factor * factor <= prime; factor++) {\n        if (prime % factor === 0) {\n          continue outer;\n        }\n      }\n\n      if (i < 8) {\n        this._init[i * 2] = frac(Math.pow(prime, 1 / 2));\n        this._init[i * 2 + 1] = frac2(Math.pow(prime, 1 / 2)) << 24 | this._initr[i];\n      }\n\n      this._key[i * 2] = frac(Math.pow(prime, 1 / 3));\n      this._key[i * 2 + 1] = frac2(Math.pow(prime, 1 / 3)) << 24 | this._keyr[i];\n      i++;\n    }\n  },\n  _block: function _block(words) {\n    var i,\n        wrh,\n        wrl,\n        w = words.slice(0),\n        h = this._h,\n        k = this._key,\n        h0h = h[0],\n        h0l = h[1],\n        h1h = h[2],\n        h1l = h[3],\n        h2h = h[4],\n        h2l = h[5],\n        h3h = h[6],\n        h3l = h[7],\n        h4h = h[8],\n        h4l = h[9],\n        h5h = h[10],\n        h5l = h[11],\n        h6h = h[12],\n        h6l = h[13],\n        h7h = h[14],\n        h7l = h[15];\n    var ah = h0h,\n        al = h0l,\n        bh = h1h,\n        bl = h1l,\n        ch = h2h,\n        cl = h2l,\n        dh = h3h,\n        dl = h3l,\n        eh = h4h,\n        el = h4l,\n        fh = h5h,\n        fl = h5l,\n        gh = h6h,\n        gl = h6l,\n        hh = h7h,\n        hl = h7l;\n\n    for (i = 0; i < 80; i++) {\n      if (i < 16) {\n        wrh = w[i * 2];\n        wrl = w[i * 2 + 1];\n      } else {\n        var gamma0xh = w[(i - 15) * 2];\n        var gamma0xl = w[(i - 15) * 2 + 1];\n        var gamma0h = (gamma0xl << 31 | gamma0xh >>> 1) ^ (gamma0xl << 24 | gamma0xh >>> 8) ^ gamma0xh >>> 7;\n        var gamma0l = (gamma0xh << 31 | gamma0xl >>> 1) ^ (gamma0xh << 24 | gamma0xl >>> 8) ^ (gamma0xh << 25 | gamma0xl >>> 7);\n        var gamma1xh = w[(i - 2) * 2];\n        var gamma1xl = w[(i - 2) * 2 + 1];\n        var gamma1h = (gamma1xl << 13 | gamma1xh >>> 19) ^ (gamma1xh << 3 | gamma1xl >>> 29) ^ gamma1xh >>> 6;\n        var gamma1l = (gamma1xh << 13 | gamma1xl >>> 19) ^ (gamma1xl << 3 | gamma1xh >>> 29) ^ (gamma1xh << 26 | gamma1xl >>> 6);\n        var wr7h = w[(i - 7) * 2];\n        var wr7l = w[(i - 7) * 2 + 1];\n        var wr16h = w[(i - 16) * 2];\n        var wr16l = w[(i - 16) * 2 + 1];\n        wrl = gamma0l + wr7l;\n        wrh = gamma0h + wr7h + (wrl >>> 0 < gamma0l >>> 0 ? 1 : 0);\n        wrl += gamma1l;\n        wrh += gamma1h + (wrl >>> 0 < gamma1l >>> 0 ? 1 : 0);\n        wrl += wr16l;\n        wrh += wr16h + (wrl >>> 0 < wr16l >>> 0 ? 1 : 0);\n      }\n\n      w[i * 2] = wrh |= 0;\n      w[i * 2 + 1] = wrl |= 0;\n      var chh = eh & fh ^ ~eh & gh;\n      var chl = el & fl ^ ~el & gl;\n      var majh = ah & bh ^ ah & ch ^ bh & ch;\n      var majl = al & bl ^ al & cl ^ bl & cl;\n      var sigma0h = (al << 4 | ah >>> 28) ^ (ah << 30 | al >>> 2) ^ (ah << 25 | al >>> 7);\n      var sigma0l = (ah << 4 | al >>> 28) ^ (al << 30 | ah >>> 2) ^ (al << 25 | ah >>> 7);\n      var sigma1h = (el << 18 | eh >>> 14) ^ (el << 14 | eh >>> 18) ^ (eh << 23 | el >>> 9);\n      var sigma1l = (eh << 18 | el >>> 14) ^ (eh << 14 | el >>> 18) ^ (el << 23 | eh >>> 9);\n      var krh = k[i * 2];\n      var krl = k[i * 2 + 1];\n      var t1l = hl + sigma1l;\n      var t1h = hh + sigma1h + (t1l >>> 0 < hl >>> 0 ? 1 : 0);\n      t1l += chl;\n      t1h += chh + (t1l >>> 0 < chl >>> 0 ? 1 : 0);\n      t1l += krl;\n      t1h += krh + (t1l >>> 0 < krl >>> 0 ? 1 : 0);\n      t1l += wrl;\n      t1h += wrh + (t1l >>> 0 < wrl >>> 0 ? 1 : 0);\n      var t2l = sigma0l + majl;\n      var t2h = sigma0h + majh + (t2l >>> 0 < sigma0l >>> 0 ? 1 : 0);\n      hh = gh;\n      hl = gl;\n      gh = fh;\n      gl = fl;\n      fh = eh;\n      fl = el;\n      el = dl + t1l | 0;\n      eh = dh + t1h + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;\n      dh = ch;\n      dl = cl;\n      ch = bh;\n      cl = bl;\n      bh = ah;\n      bl = al;\n      al = t1l + t2l | 0;\n      ah = t1h + t2h + (al >>> 0 < t1l >>> 0 ? 1 : 0) | 0;\n    }\n\n    h0l = h[1] = h0l + al | 0;\n    h[0] = h0h + ah + (h0l >>> 0 < al >>> 0 ? 1 : 0) | 0;\n    h1l = h[3] = h1l + bl | 0;\n    h[2] = h1h + bh + (h1l >>> 0 < bl >>> 0 ? 1 : 0) | 0;\n    h2l = h[5] = h2l + cl | 0;\n    h[4] = h2h + ch + (h2l >>> 0 < cl >>> 0 ? 1 : 0) | 0;\n    h3l = h[7] = h3l + dl | 0;\n    h[6] = h3h + dh + (h3l >>> 0 < dl >>> 0 ? 1 : 0) | 0;\n    h4l = h[9] = h4l + el | 0;\n    h[8] = h4h + eh + (h4l >>> 0 < el >>> 0 ? 1 : 0) | 0;\n    h5l = h[11] = h5l + fl | 0;\n    h[10] = h5h + fh + (h5l >>> 0 < fl >>> 0 ? 1 : 0) | 0;\n    h6l = h[13] = h6l + gl | 0;\n    h[12] = h6h + gh + (h6l >>> 0 < gl >>> 0 ? 1 : 0) | 0;\n    h7l = h[15] = h7l + hl | 0;\n    h[14] = h7h + hh + (h7l >>> 0 < hl >>> 0 ? 1 : 0) | 0;\n  }\n};\n\nsjcl.hash.sha1 = function (hash) {\n  if (hash) {\n    this._h = hash._h.slice(0);\n    this._buffer = hash._buffer.slice(0);\n    this._length = hash._length;\n  } else {\n    this.reset();\n  }\n};\n\nsjcl.hash.sha1.hash = function (data) {\n  return new sjcl.hash.sha1().update(data).finalize();\n};\n\nsjcl.hash.sha1.prototype = {\n  blockSize: 512,\n  reset: function reset() {\n    this._h = this._init.slice(0);\n    this._buffer = [];\n    this._length = 0;\n    return this;\n  },\n  update: function update(data) {\n    if (typeof data === \"string\") {\n      data = sjcl.codec.utf8String.toBits(data);\n    }\n\n    var i,\n        b = this._buffer = sjcl.bitArray.concat(this._buffer, data),\n        ol = this._length,\n        nl = this._length = ol + sjcl.bitArray.bitLength(data);\n\n    for (i = this.blockSize + ol & -this.blockSize; i <= nl; i += this.blockSize) {\n      this._block(b.splice(0, 16));\n    }\n\n    return this;\n  },\n  finalize: function finalize() {\n    var i,\n        b = this._buffer,\n        h = this._h;\n    b = sjcl.bitArray.concat(b, [sjcl.bitArray.partial(1, 1)]);\n\n    for (i = b.length + 2; i & 15; i++) {\n      b.push(0);\n    }\n\n    b.push(Math.floor(this._length / 0x100000000));\n    b.push(this._length | 0);\n\n    while (b.length) {\n      this._block(b.splice(0, 16));\n    }\n\n    this.reset();\n    return h;\n  },\n  _init: [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0],\n  _key: [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xca62c1d6],\n  _f: function _f(t, b, c, d) {\n    if (t <= 19) {\n      return b & c | ~b & d;\n    } else if (t <= 39) {\n      return b ^ c ^ d;\n    } else if (t <= 59) {\n      return b & c | b & d | c & d;\n    } else if (t <= 79) {\n      return b ^ c ^ d;\n    }\n  },\n  _S: function _S(n, x) {\n    return x << n | x >>> 32 - n;\n  },\n  _block: function _block(words) {\n    var t,\n        tmp,\n        a,\n        b,\n        c,\n        d,\n        e,\n        w = words.slice(0),\n        h = this._h,\n        k = this._key;\n    a = h[0];\n    b = h[1];\n    c = h[2];\n    d = h[3];\n    e = h[4];\n\n    for (t = 0; t <= 79; t++) {\n      if (t >= 16) {\n        w[t] = this._S(1, w[t - 3] ^ w[t - 8] ^ w[t - 14] ^ w[t - 16]);\n      }\n\n      tmp = this._S(5, a) + this._f(t, b, c, d) + e + w[t] + this._key[Math.floor(t / 20)] | 0;\n      e = d;\n      d = c;\n      c = this._S(30, b);\n      b = a;\n      a = tmp;\n    }\n\n    h[0] = h[0] + a | 0;\n    h[1] = h[1] + b | 0;\n    h[2] = h[2] + c | 0;\n    h[3] = h[3] + d | 0;\n    h[4] = h[4] + e | 0;\n  }\n};\nsjcl.mode.ccm = {\n  name: \"ccm\",\n  encrypt: function encrypt(prf, plaintext, iv, adata, tlen) {\n    var L,\n        i,\n        out = plaintext.slice(0),\n        tag,\n        w = sjcl.bitArray,\n        ivl = w.bitLength(iv) / 8,\n        ol = w.bitLength(out) / 8;\n    tlen = tlen || 64;\n    adata = adata || [];\n\n    if (ivl < 7) {\n      throw new sjcl.exception.invalid(\"ccm: iv must be at least 7 bytes\");\n    }\n\n    for (L = 2; L < 4 && ol >>> 8 * L; L++) {}\n\n    if (L < 15 - ivl) {\n      L = 15 - ivl;\n    }\n\n    iv = w.clamp(iv, 8 * (15 - L));\n    tag = sjcl.mode.ccm._computeTag(prf, plaintext, iv, adata, tlen, L);\n    out = sjcl.mode.ccm._ctrMode(prf, out, iv, tag, tlen, L);\n    return w.concat(out.data, out.tag);\n  },\n  decrypt: function decrypt(prf, ciphertext, iv, adata, tlen) {\n    tlen = tlen || 64;\n    adata = adata || [];\n    var L,\n        i,\n        w = sjcl.bitArray,\n        ivl = w.bitLength(iv) / 8,\n        ol = w.bitLength(ciphertext),\n        out = w.clamp(ciphertext, ol - tlen),\n        tag = w.bitSlice(ciphertext, ol - tlen),\n        tag2;\n    ol = (ol - tlen) / 8;\n\n    if (ivl < 7) {\n      throw new sjcl.exception.invalid(\"ccm: iv must be at least 7 bytes\");\n    }\n\n    for (L = 2; L < 4 && ol >>> 8 * L; L++) {}\n\n    if (L < 15 - ivl) {\n      L = 15 - ivl;\n    }\n\n    iv = w.clamp(iv, 8 * (15 - L));\n    out = sjcl.mode.ccm._ctrMode(prf, out, iv, tag, tlen, L);\n    tag2 = sjcl.mode.ccm._computeTag(prf, out.data, iv, adata, tlen, L);\n\n    if (!w.equal(out.tag, tag2)) {\n      throw new sjcl.exception.corrupt(\"ccm: tag doesn't match\");\n    }\n\n    return out.data;\n  },\n  _computeTag: function _computeTag(prf, plaintext, iv, adata, tlen, L) {\n    var q,\n        mac,\n        field = 0,\n        offset = 24,\n        tmp,\n        i,\n        macData = [],\n        w = sjcl.bitArray,\n        xor = w._xor4;\n    tlen /= 8;\n\n    if (tlen % 2 || tlen < 4 || tlen > 16) {\n      throw new sjcl.exception.invalid(\"ccm: invalid tag length\");\n    }\n\n    if (adata.length > 0xffffffff || plaintext.length > 0xffffffff) {\n      throw new sjcl.exception.bug(\"ccm: can't deal with 4GiB or more data\");\n    }\n\n    mac = [w.partial(8, (adata.length ? 1 << 6 : 0) | tlen - 2 << 2 | L - 1)];\n    mac = w.concat(mac, iv);\n    mac[3] |= w.bitLength(plaintext) / 8;\n    mac = prf.encrypt(mac);\n\n    if (adata.length) {\n      tmp = w.bitLength(adata) / 8;\n\n      if (tmp <= 0xfeff) {\n        macData = [w.partial(16, tmp)];\n      } else if (tmp <= 0xffffffff) {\n        macData = w.concat([w.partial(16, 0xfffe)], [tmp]);\n      }\n\n      macData = w.concat(macData, adata);\n\n      for (i = 0; i < macData.length; i += 4) {\n        mac = prf.encrypt(xor(mac, macData.slice(i, i + 4).concat([0, 0, 0])));\n      }\n    }\n\n    for (i = 0; i < plaintext.length; i += 4) {\n      mac = prf.encrypt(xor(mac, plaintext.slice(i, i + 4).concat([0, 0, 0])));\n    }\n\n    return w.clamp(mac, tlen * 8);\n  },\n  _ctrMode: function _ctrMode(prf, data, iv, tag, tlen, L) {\n    var enc,\n        i,\n        w = sjcl.bitArray,\n        xor = w._xor4,\n        ctr,\n        b,\n        l = data.length,\n        bl = w.bitLength(data);\n    ctr = w.concat([w.partial(8, L - 1)], iv).concat([0, 0, 0]).slice(0, 4);\n    tag = w.bitSlice(xor(tag, prf.encrypt(ctr)), 0, tlen);\n\n    if (!l) {\n      return {\n        tag: tag,\n        data: []\n      };\n    }\n\n    for (i = 0; i < l; i += 4) {\n      ctr[3]++;\n      enc = prf.encrypt(ctr);\n      data[i] ^= enc[0];\n      data[i + 1] ^= enc[1];\n      data[i + 2] ^= enc[2];\n      data[i + 3] ^= enc[3];\n    }\n\n    return {\n      tag: tag,\n      data: w.clamp(data, bl)\n    };\n  }\n};\n\nsjcl.misc.hmac = function (key, Hash) {\n  this._hash = Hash = Hash || sjcl.hash.sha256;\n  var exKey = [[], []],\n      i,\n      bs = Hash.prototype.blockSize / 32;\n  this._baseHash = [new Hash(), new Hash()];\n\n  if (key.length > bs) {\n    key = Hash.hash(key);\n  }\n\n  for (i = 0; i < bs; i++) {\n    exKey[0][i] = key[i] ^ 0x36363636;\n    exKey[1][i] = key[i] ^ 0x5c5c5c5c;\n  }\n\n  this._baseHash[0].update(exKey[0]);\n\n  this._baseHash[1].update(exKey[1]);\n};\n\nsjcl.misc.hmac.prototype.encrypt = sjcl.misc.hmac.prototype.mac = function (data) {\n  var w = new this._hash(this._baseHash[0]).update(data).finalize();\n  return new this._hash(this._baseHash[1]).update(w).finalize();\n};\n\nsjcl.misc.pbkdf2 = function (password, salt, count, length, Prff) {\n  count = count || 1000;\n\n  if (length < 0 || count < 0) {\n    throw sjcl.exception.invalid(\"invalid params to pbkdf2\");\n  }\n\n  if (typeof password === \"string\") {\n    password = sjcl.codec.utf8String.toBits(password);\n  }\n\n  Prff = Prff || sjcl.misc.hmac;\n  var prf = new Prff(password),\n      u,\n      ui,\n      i,\n      j,\n      k,\n      out = [],\n      b = sjcl.bitArray;\n\n  for (k = 1; 32 * out.length < (length || 1); k++) {\n    u = ui = prf.encrypt(b.concat(salt, [k]));\n\n    for (i = 1; i < count; i++) {\n      ui = prf.encrypt(ui);\n\n      for (j = 0; j < ui.length; j++) {\n        u[j] ^= ui[j];\n      }\n    }\n\n    out = out.concat(u);\n  }\n\n  if (length) {\n    out = b.clamp(out, length);\n  }\n\n  return out;\n};\n\nsjcl.prng = function (defaultParanoia) {\n  this._pools = [new sjcl.hash.sha256()];\n  this._poolEntropy = [0];\n  this._reseedCount = 0;\n  this._robins = {};\n  this._eventId = 0;\n  this._collectorIds = {};\n  this._collectorIdNext = 0;\n  this._strength = 0;\n  this._poolStrength = 0;\n  this._nextReseed = 0;\n  this._key = [0, 0, 0, 0, 0, 0, 0, 0];\n  this._counter = [0, 0, 0, 0];\n  this._cipher = undefined;\n  this._defaultParanoia = defaultParanoia;\n  this._collectorsStarted = false;\n  this._callbacks = {\n    progress: {},\n    seeded: {}\n  };\n  this._callbackI = 0;\n  this._NOT_READY = 0;\n  this._READY = 1;\n  this._REQUIRES_RESEED = 2;\n  this._MAX_WORDS_PER_BURST = 65536;\n  this._PARANOIA_LEVELS = [0, 48, 64, 96, 128, 192, 256, 384, 512, 768, 1024];\n  this._MILLISECONDS_PER_RESEED = 30000;\n  this._BITS_PER_RESEED = 80;\n};\n\nsjcl.prng.prototype = {\n  randomWords: function randomWords(nwords, paranoia) {\n    var out = [],\n        i,\n        readiness = this.isReady(paranoia),\n        g;\n\n    if (readiness === this._NOT_READY) {\n      throw new sjcl.exception.notReady(\"generator isn't seeded\");\n    } else if (readiness & this._REQUIRES_RESEED) {\n      this._reseedFromPools(!(readiness & this._READY));\n    }\n\n    for (i = 0; i < nwords; i += 4) {\n      if ((i + 1) % this._MAX_WORDS_PER_BURST === 0) {\n        this._gate();\n      }\n\n      g = this._gen4words();\n      out.push(g[0], g[1], g[2], g[3]);\n    }\n\n    this._gate();\n\n    return out.slice(0, nwords);\n  },\n  setDefaultParanoia: function setDefaultParanoia(paranoia) {\n    this._defaultParanoia = paranoia;\n  },\n  addEntropy: function addEntropy(data, estimatedEntropy, source) {\n    source = source || \"user\";\n    var id,\n        i,\n        tmp,\n        t = new Date().valueOf(),\n        robin = this._robins[source],\n        oldReady = this.isReady(),\n        err = 0;\n    id = this._collectorIds[source];\n\n    if (id === undefined) {\n      id = this._collectorIds[source] = this._collectorIdNext++;\n    }\n\n    if (robin === undefined) {\n      robin = this._robins[source] = 0;\n    }\n\n    this._robins[source] = (this._robins[source] + 1) % this._pools.length;\n\n    switch (typeof data) {\n      case \"number\":\n        if (estimatedEntropy === undefined) {\n          estimatedEntropy = 1;\n        }\n\n        this._pools[robin].update([id, this._eventId++, 1, estimatedEntropy, t, 1, data | 0]);\n\n        break;\n\n      case \"object\":\n        var objName = Object.prototype.toString.call(data);\n\n        if (objName === \"[object Uint32Array]\") {\n          tmp = [];\n\n          for (i = 0; i < data.length; i++) {\n            tmp.push(data[i]);\n          }\n\n          data = tmp;\n        } else {\n          if (objName !== \"[object Array]\") {\n            err = 1;\n          }\n\n          for (i = 0; i < data.length && !err; i++) {\n            if (typeof data[i] != \"number\") {\n              err = 1;\n            }\n          }\n        }\n\n        if (!err) {\n          if (estimatedEntropy === undefined) {\n            estimatedEntropy = 0;\n\n            for (i = 0; i < data.length; i++) {\n              tmp = data[i];\n\n              while (tmp > 0) {\n                estimatedEntropy++;\n                tmp = tmp >>> 1;\n              }\n            }\n          }\n\n          this._pools[robin].update([id, this._eventId++, 2, estimatedEntropy, t, data.length].concat(data));\n        }\n\n        break;\n\n      case \"string\":\n        if (estimatedEntropy === undefined) {\n          estimatedEntropy = data.length;\n        }\n\n        this._pools[robin].update([id, this._eventId++, 3, estimatedEntropy, t, data.length]);\n\n        this._pools[robin].update(data);\n\n        break;\n\n      default:\n        err = 1;\n    }\n\n    if (err) {\n      throw new sjcl.exception.bug(\"random: addEntropy only supports number, array of numbers or string\");\n    }\n\n    this._poolEntropy[robin] += estimatedEntropy;\n    this._poolStrength += estimatedEntropy;\n\n    if (oldReady === this._NOT_READY) {\n      if (this.isReady() !== this._NOT_READY) {\n        this._fireEvent(\"seeded\", Math.max(this._strength, this._poolStrength));\n      }\n\n      this._fireEvent(\"progress\", this.getProgress());\n    }\n  },\n  isReady: function isReady(paranoia) {\n    var entropyRequired = this._PARANOIA_LEVELS[paranoia !== undefined ? paranoia : this._defaultParanoia];\n\n    if (this._strength && this._strength >= entropyRequired) {\n      return this._poolEntropy[0] > this._BITS_PER_RESEED && new Date().valueOf() > this._nextReseed ? this._REQUIRES_RESEED | this._READY : this._READY;\n    } else {\n      return this._poolStrength >= entropyRequired ? this._REQUIRES_RESEED | this._NOT_READY : this._NOT_READY;\n    }\n  },\n  getProgress: function getProgress(paranoia) {\n    var entropyRequired = this._PARANOIA_LEVELS[paranoia ? paranoia : this._defaultParanoia];\n\n    if (this._strength >= entropyRequired) {\n      return 1.0;\n    } else {\n      return this._poolStrength > entropyRequired ? 1.0 : this._poolStrength / entropyRequired;\n    }\n  },\n  startCollectors: function startCollectors() {\n    if (this._collectorsStarted) {\n      return;\n    }\n\n    if (window.addEventListener) {\n      window.addEventListener(\"load\", this._loadTimeCollector, false);\n      window.addEventListener(\"mousemove\", this._mouseCollector, false);\n    } else if (document.attachEvent) {\n      document.attachEvent(\"onload\", this._loadTimeCollector);\n      document.attachEvent(\"onmousemove\", this._mouseCollector);\n    } else {\n      throw new sjcl.exception.bug(\"can't attach event\");\n    }\n\n    this._collectorsStarted = true;\n  },\n  stopCollectors: function stopCollectors() {\n    if (!this._collectorsStarted) {\n      return;\n    }\n\n    if (window.removeEventListener) {\n      window.removeEventListener(\"load\", this._loadTimeCollector, false);\n      window.removeEventListener(\"mousemove\", this._mouseCollector, false);\n    } else if (window.detachEvent) {\n      window.detachEvent(\"onload\", this._loadTimeCollector);\n      window.detachEvent(\"onmousemove\", this._mouseCollector);\n    }\n\n    this._collectorsStarted = false;\n  },\n  addEventListener: function addEventListener(name, callback) {\n    this._callbacks[name][this._callbackI++] = callback;\n  },\n  removeEventListener: function removeEventListener(name, cb) {\n    var i,\n        j,\n        cbs = this._callbacks[name],\n        jsTemp = [];\n\n    for (j in cbs) {\n      if (cbs.hasOwnProperty(j) && cbs[j] === cb) {\n        jsTemp.push(j);\n      }\n    }\n\n    for (i = 0; i < jsTemp.length; i++) {\n      j = jsTemp[i];\n      delete cbs[j];\n    }\n  },\n  _gen4words: function _gen4words() {\n    for (var i = 0; i < 4; i++) {\n      this._counter[i] = this._counter[i] + 1 | 0;\n\n      if (this._counter[i]) {\n        break;\n      }\n    }\n\n    return this._cipher.encrypt(this._counter);\n  },\n  _gate: function _gate() {\n    this._key = this._gen4words().concat(this._gen4words());\n    this._cipher = new sjcl.cipher.aes(this._key);\n  },\n  _reseed: function _reseed(seedWords) {\n    this._key = sjcl.hash.sha256.hash(this._key.concat(seedWords));\n    this._cipher = new sjcl.cipher.aes(this._key);\n\n    for (var i = 0; i < 4; i++) {\n      this._counter[i] = this._counter[i] + 1 | 0;\n\n      if (this._counter[i]) {\n        break;\n      }\n    }\n  },\n  _reseedFromPools: function _reseedFromPools(full) {\n    var reseedData = [],\n        strength = 0,\n        i;\n    this._nextReseed = reseedData[0] = new Date().valueOf() + this._MILLISECONDS_PER_RESEED;\n\n    for (i = 0; i < 16; i++) {\n      reseedData.push(Math.random() * 0x100000000 | 0);\n    }\n\n    for (i = 0; i < this._pools.length; i++) {\n      reseedData = reseedData.concat(this._pools[i].finalize());\n      strength += this._poolEntropy[i];\n      this._poolEntropy[i] = 0;\n\n      if (!full && this._reseedCount & 1 << i) {\n        break;\n      }\n    }\n\n    if (this._reseedCount >= 1 << this._pools.length) {\n      this._pools.push(new sjcl.hash.sha256());\n\n      this._poolEntropy.push(0);\n    }\n\n    this._poolStrength -= strength;\n\n    if (strength > this._strength) {\n      this._strength = strength;\n    }\n\n    this._reseedCount++;\n\n    this._reseed(reseedData);\n  },\n  _mouseCollector: function _mouseCollector(ev) {\n    var x = ev.x || ev.clientX || ev.offsetX || 0,\n        y = ev.y || ev.clientY || ev.offsetY || 0;\n    sjcl.random.addEntropy([x, y], 2, \"mouse\");\n  },\n  _loadTimeCollector: function _loadTimeCollector(ev) {\n    sjcl.random.addEntropy(new Date().valueOf(), 2, \"loadtime\");\n  },\n  _fireEvent: function _fireEvent(name, arg) {\n    var j,\n        cbs = sjcl.random._callbacks[name],\n        cbsTemp = [];\n\n    for (j in cbs) {\n      if (cbs.hasOwnProperty(j)) {\n        cbsTemp.push(cbs[j]);\n      }\n    }\n\n    for (j = 0; j < cbsTemp.length; j++) {\n      cbsTemp[j](arg);\n    }\n  }\n};\nsjcl.random = new sjcl.prng(6);\n\n(function () {\n  try {\n    var ab = new Uint32Array(32);\n    crypto.getRandomValues(ab);\n    sjcl.random.addEntropy(ab, 1024, \"crypto.getRandomValues\");\n  } catch (e) {}\n})();\n\nsjcl.json = {\n  defaults: {\n    v: 1,\n    iter: 1000,\n    ks: 128,\n    ts: 64,\n    mode: \"ccm\",\n    adata: \"\",\n    cipher: \"aes\"\n  },\n  encrypt: function encrypt(password, plaintext, params, rp) {\n    params = params || {};\n    rp = rp || {};\n\n    var j = sjcl.json,\n        p = j._add({\n      iv: sjcl.random.randomWords(4, 0)\n    }, j.defaults),\n        tmp,\n        prp,\n        adata;\n\n    j._add(p, params);\n\n    adata = p.adata;\n\n    if (typeof p.salt === \"string\") {\n      p.salt = sjcl.codec.base64.toBits(p.salt);\n    }\n\n    if (typeof p.iv === \"string\") {\n      p.iv = sjcl.codec.base64.toBits(p.iv);\n    }\n\n    if (!sjcl.mode[p.mode] || !sjcl.cipher[p.cipher] || typeof password === \"string\" && p.iter <= 100 || p.ts !== 64 && p.ts !== 96 && p.ts !== 128 || p.ks !== 128 && p.ks !== 192 && p.ks !== 256 || p.iv.length < 2 || p.iv.length > 4) {\n      throw new sjcl.exception.invalid(\"json encrypt: invalid parameters\");\n    }\n\n    if (typeof password === \"string\") {\n      tmp = sjcl.misc.cachedPbkdf2(password, p);\n      password = tmp.key.slice(0, p.ks / 32);\n      p.salt = tmp.salt;\n    } else if (sjcl.ecc && password instanceof sjcl.ecc.elGamal.publicKey) {\n      tmp = password.kem();\n      p.kemtag = tmp.tag;\n      password = tmp.key.slice(0, p.ks / 32);\n    }\n\n    if (typeof plaintext === \"string\") {\n      plaintext = sjcl.codec.utf8String.toBits(plaintext);\n    }\n\n    if (typeof adata === \"string\") {\n      adata = sjcl.codec.utf8String.toBits(adata);\n    }\n\n    prp = new sjcl.cipher[p.cipher](password);\n\n    j._add(rp, p);\n\n    rp.key = password;\n    p.ct = sjcl.mode[p.mode].encrypt(prp, plaintext, p.iv, adata, p.ts);\n    return j.encode(p);\n  },\n  decrypt: function decrypt(password, ciphertext, params, rp) {\n    params = params || {};\n    rp = rp || {};\n\n    var j = sjcl.json,\n        p = j._add(j._add(j._add({}, j.defaults), j.decode(ciphertext)), params, true),\n        ct,\n        tmp,\n        prp,\n        adata = p.adata;\n\n    if (typeof p.salt === \"string\") {\n      p.salt = sjcl.codec.base64.toBits(p.salt);\n    }\n\n    if (typeof p.iv === \"string\") {\n      p.iv = sjcl.codec.base64.toBits(p.iv);\n    }\n\n    if (!sjcl.mode[p.mode] || !sjcl.cipher[p.cipher] || typeof password === \"string\" && p.iter <= 100 || p.ts !== 64 && p.ts !== 96 && p.ts !== 128 || p.ks !== 128 && p.ks !== 192 && p.ks !== 256 || !p.iv || p.iv.length < 2 || p.iv.length > 4) {\n      throw new sjcl.exception.invalid(\"json decrypt: invalid parameters\");\n    }\n\n    if (typeof password === \"string\") {\n      tmp = sjcl.misc.cachedPbkdf2(password, p);\n      password = tmp.key.slice(0, p.ks / 32);\n      p.salt = tmp.salt;\n    } else if (sjcl.ecc && password instanceof sjcl.ecc.elGamal.secretKey) {\n      password = password.unkem(sjcl.codec.base64.toBits(p.kemtag)).slice(0, p.ks / 32);\n    }\n\n    if (typeof adata === \"string\") {\n      adata = sjcl.codec.utf8String.toBits(adata);\n    }\n\n    prp = new sjcl.cipher[p.cipher](password);\n    ct = sjcl.mode[p.mode].decrypt(prp, p.ct, p.iv, adata, p.ts);\n\n    j._add(rp, p);\n\n    rp.key = password;\n    return sjcl.codec.utf8String.fromBits(ct);\n  },\n  encode: function encode(obj) {\n    var i,\n        out = \"{\",\n        comma = \"\";\n\n    for (i in obj) {\n      if (obj.hasOwnProperty(i)) {\n        if (!i.match(/^[a-z0-9]+$/i)) {\n          throw new sjcl.exception.invalid(\"json encode: invalid property name\");\n        }\n\n        out += comma + '\"' + i + '\":';\n        comma = \",\";\n\n        switch (typeof obj[i]) {\n          case \"number\":\n          case \"boolean\":\n            out += obj[i];\n            break;\n\n          case \"string\":\n            out += '\"' + escape(obj[i]) + '\"';\n            break;\n\n          case \"object\":\n            out += '\"' + sjcl.codec.base64.fromBits(obj[i], 0) + '\"';\n            break;\n\n          default:\n            throw new sjcl.exception.bug(\"json encode: unsupported type\");\n        }\n      }\n    }\n\n    return out + \"}\";\n  },\n  decode: function decode(str) {\n    str = str.replace(/\\s/g, \"\");\n\n    if (!str.match(/^\\{.*\\}$/)) {\n      throw new sjcl.exception.invalid(\"json decode: this isn't json!\");\n    }\n\n    var a = str.replace(/^\\{|\\}$/g, \"\").split(/,/),\n        out = {},\n        i,\n        m;\n\n    for (i = 0; i < a.length; i++) {\n      if (!(m = a[i].match(/^(?:([\"']?)([a-z][a-z0-9]*)\\1):(?:(\\d+)|\"([a-z0-9+\\/%*_.@=\\-]*)\")$/i))) {\n        throw new sjcl.exception.invalid(\"json decode: this isn't json!\");\n      }\n\n      if (m[3]) {\n        out[m[2]] = parseInt(m[3], 10);\n      } else {\n        out[m[2]] = m[2].match(/^(ct|salt|iv)$/) ? sjcl.codec.base64.toBits(m[4]) : unescape(m[4]);\n      }\n    }\n\n    return out;\n  },\n  _add: function _add(target, src, requireSame) {\n    if (target === undefined) {\n      target = {};\n    }\n\n    if (src === undefined) {\n      return target;\n    }\n\n    var i;\n\n    for (i in src) {\n      if (src.hasOwnProperty(i)) {\n        if (requireSame && target[i] !== undefined && target[i] !== src[i]) {\n          throw new sjcl.exception.invalid(\"required parameter overridden\");\n        }\n\n        target[i] = src[i];\n      }\n    }\n\n    return target;\n  },\n  _subtract: function _subtract(plus, minus) {\n    var out = {},\n        i;\n\n    for (i in plus) {\n      if (plus.hasOwnProperty(i) && plus[i] !== minus[i]) {\n        out[i] = plus[i];\n      }\n    }\n\n    return out;\n  },\n  _filter: function _filter(src, filter) {\n    var out = {},\n        i;\n\n    for (i = 0; i < filter.length; i++) {\n      if (src[filter[i]] !== undefined) {\n        out[filter[i]] = src[filter[i]];\n      }\n    }\n\n    return out;\n  }\n};\nsjcl.encrypt = sjcl.json.encrypt;\nsjcl.decrypt = sjcl.json.decrypt;\nsjcl.misc._pbkdf2Cache = {};\n\nsjcl.misc.cachedPbkdf2 = function (password, obj) {\n  var cache = sjcl.misc._pbkdf2Cache,\n      c,\n      cp,\n      str,\n      salt,\n      iter;\n  obj = obj || {};\n  iter = obj.iter || 1000;\n  cp = cache[password] = cache[password] || {};\n  c = cp[iter] = cp[iter] || {\n    firstSalt: obj.salt && obj.salt.length ? obj.salt.slice(0) : sjcl.random.randomWords(2, 0)\n  };\n  salt = obj.salt === undefined ? c.firstSalt : obj.salt;\n  c[salt] = c[salt] || sjcl.misc.pbkdf2(password, salt, obj.iter);\n  return {\n    key: c[salt].slice(0),\n    salt: salt.slice(0)\n  };\n};\n\nsjcl.bn = function (it) {\n  this.initWith(it);\n};\n\nsjcl.bn.prototype = {\n  radix: 24,\n  maxMul: 8,\n  _class: sjcl.bn,\n  copy: function copy() {\n    return new this._class(this);\n  },\n  initWith: function initWith(it) {\n    var i = 0,\n        k,\n        n,\n        l;\n\n    switch (typeof it) {\n      case \"object\":\n        this.limbs = it.limbs.slice(0);\n        break;\n\n      case \"number\":\n        this.limbs = [it];\n        this.normalize();\n        break;\n\n      case \"string\":\n        it = it.replace(/^0x/, \"\");\n        this.limbs = [];\n        k = this.radix / 4;\n\n        for (i = 0; i < it.length; i += k) {\n          this.limbs.push(parseInt(it.substring(Math.max(it.length - i - k, 0), it.length - i), 16));\n        }\n\n        break;\n\n      default:\n        this.limbs = [0];\n    }\n\n    return this;\n  },\n  equals: function equals(that) {\n    if (typeof that === \"number\") {\n      that = new this._class(that);\n    }\n\n    var difference = 0,\n        i;\n    this.fullReduce();\n    that.fullReduce();\n\n    for (i = 0; i < this.limbs.length || i < that.limbs.length; i++) {\n      difference |= this.getLimb(i) ^ that.getLimb(i);\n    }\n\n    return difference === 0;\n  },\n  getLimb: function getLimb(i) {\n    return i >= this.limbs.length ? 0 : this.limbs[i];\n  },\n  greaterEquals: function greaterEquals(that) {\n    if (typeof that === \"number\") {\n      that = new this._class(that);\n    }\n\n    var less = 0,\n        greater = 0,\n        i,\n        a,\n        b;\n    i = Math.max(this.limbs.length, that.limbs.length) - 1;\n\n    for (; i >= 0; i--) {\n      a = this.getLimb(i);\n      b = that.getLimb(i);\n      greater |= b - a & ~less;\n      less |= a - b & ~greater;\n    }\n\n    return (greater | ~less) >>> 31;\n  },\n  toString: function toString() {\n    this.fullReduce();\n    var out = \"\",\n        i,\n        s,\n        l = this.limbs;\n\n    for (i = 0; i < this.limbs.length; i++) {\n      s = l[i].toString(16);\n\n      while (i < this.limbs.length - 1 && s.length < 6) {\n        s = \"0\" + s;\n      }\n\n      out = s + out;\n    }\n\n    return \"0x\" + out;\n  },\n  addM: function addM(that) {\n    if (typeof that !== \"object\") {\n      that = new this._class(that);\n    }\n\n    var i,\n        l = this.limbs,\n        ll = that.limbs;\n\n    for (i = l.length; i < ll.length; i++) {\n      l[i] = 0;\n    }\n\n    for (i = 0; i < ll.length; i++) {\n      l[i] += ll[i];\n    }\n\n    return this;\n  },\n  doubleM: function doubleM() {\n    var i,\n        carry = 0,\n        tmp,\n        r = this.radix,\n        m = this.radixMask,\n        l = this.limbs;\n\n    for (i = 0; i < l.length; i++) {\n      tmp = l[i];\n      tmp = tmp + tmp + carry;\n      l[i] = tmp & m;\n      carry = tmp >> r;\n    }\n\n    if (carry) {\n      l.push(carry);\n    }\n\n    return this;\n  },\n  halveM: function halveM() {\n    var i,\n        carry = 0,\n        tmp,\n        r = this.radix,\n        l = this.limbs;\n\n    for (i = l.length - 1; i >= 0; i--) {\n      tmp = l[i];\n      l[i] = tmp + carry >> 1;\n      carry = (tmp & 1) << r;\n    }\n\n    if (!l[l.length - 1]) {\n      l.pop();\n    }\n\n    return this;\n  },\n  subM: function subM(that) {\n    if (typeof that !== \"object\") {\n      that = new this._class(that);\n    }\n\n    var i,\n        l = this.limbs,\n        ll = that.limbs;\n\n    for (i = l.length; i < ll.length; i++) {\n      l[i] = 0;\n    }\n\n    for (i = 0; i < ll.length; i++) {\n      l[i] -= ll[i];\n    }\n\n    return this;\n  },\n  mod: function mod(that) {\n    var neg = !this.greaterEquals(new sjcl.bn(0));\n    that = new sjcl.bn(that).normalize();\n    var out = new sjcl.bn(this).normalize(),\n        ci = 0;\n    if (neg) out = new sjcl.bn(0).subM(out).normalize();\n\n    for (; out.greaterEquals(that); ci++) {\n      that.doubleM();\n    }\n\n    if (neg) out = that.sub(out).normalize();\n\n    for (; ci > 0; ci--) {\n      that.halveM();\n\n      if (out.greaterEquals(that)) {\n        out.subM(that).normalize();\n      }\n    }\n\n    return out.trim();\n  },\n  inverseMod: function inverseMod(p) {\n    var a = new sjcl.bn(1),\n        b = new sjcl.bn(0),\n        x = new sjcl.bn(this),\n        y = new sjcl.bn(p),\n        tmp,\n        i,\n        nz = 1;\n\n    do {\n      if (x.limbs[0] & 1) {\n        if (!x.greaterEquals(y)) {\n          tmp = x;\n          x = y;\n          y = tmp;\n          tmp = a;\n          a = b;\n          b = tmp;\n        }\n\n        x.subM(y);\n        x.normalize();\n\n        if (!a.greaterEquals(b)) {\n          a.addM(p);\n        }\n\n        a.subM(b);\n      }\n\n      x.halveM();\n\n      if (a.limbs[0] & 1) {\n        a.addM(p);\n      }\n\n      a.normalize();\n      a.halveM();\n\n      for (i = nz = 0; i < x.limbs.length; i++) {\n        nz |= x.limbs[i];\n      }\n    } while (nz);\n\n    if (!y.equals(1)) {\n      throw new sjcl.exception.invalid(\"inverseMod: p and x must be relatively prime\");\n    }\n\n    return b;\n  },\n  add: function add(that) {\n    return this.copy().addM(that);\n  },\n  sub: function sub(that) {\n    return this.copy().subM(that);\n  },\n  mul: function mul(that) {\n    if (typeof that === \"number\") {\n      that = new this._class(that);\n    }\n\n    var i,\n        j,\n        a = this.limbs,\n        b = that.limbs,\n        al = a.length,\n        bl = b.length,\n        out = new this._class(),\n        c = out.limbs,\n        ai,\n        ii = this.maxMul;\n\n    for (i = 0; i < this.limbs.length + that.limbs.length + 1; i++) {\n      c[i] = 0;\n    }\n\n    for (i = 0; i < al; i++) {\n      ai = a[i];\n\n      for (j = 0; j < bl; j++) {\n        c[i + j] += ai * b[j];\n      }\n\n      if (! --ii) {\n        ii = this.maxMul;\n        out.cnormalize();\n      }\n    }\n\n    return out.cnormalize().reduce();\n  },\n  square: function square() {\n    return this.mul(this);\n  },\n  power: function power(l) {\n    if (typeof l === \"number\") {\n      l = [l];\n    } else if (l.limbs !== undefined) {\n      l = l.normalize().limbs;\n    }\n\n    var i,\n        j,\n        out = new this._class(1),\n        pow = this;\n\n    for (i = 0; i < l.length; i++) {\n      for (j = 0; j < this.radix; j++) {\n        if (l[i] & 1 << j) {\n          out = out.mul(pow);\n        }\n\n        pow = pow.square();\n      }\n    }\n\n    return out;\n  },\n  mulmod: function mulmod(that, N) {\n    return this.mod(N).mul(that.mod(N)).mod(N);\n  },\n  powermod: function powermod(x, N) {\n    var result = new sjcl.bn(1),\n        a = new sjcl.bn(this),\n        k = new sjcl.bn(x);\n\n    while (true) {\n      if (k.limbs[0] & 1) {\n        result = result.mulmod(a, N);\n      }\n\n      k.halveM();\n\n      if (k.equals(0)) {\n        break;\n      }\n\n      a = a.mulmod(a, N);\n    }\n\n    return result.normalize().reduce();\n  },\n  trim: function trim() {\n    var l = this.limbs,\n        p;\n\n    do {\n      p = l.pop();\n    } while (l.length && p === 0);\n\n    l.push(p);\n    return this;\n  },\n  reduce: function reduce() {\n    return this;\n  },\n  fullReduce: function fullReduce() {\n    return this.normalize();\n  },\n  normalize: function normalize() {\n    var carry = 0,\n        i,\n        pv = this.placeVal,\n        ipv = this.ipv,\n        l,\n        m,\n        limbs = this.limbs,\n        ll = limbs.length,\n        mask = this.radixMask;\n\n    for (i = 0; i < ll || carry !== 0 && carry !== -1; i++) {\n      l = (limbs[i] || 0) + carry;\n      m = limbs[i] = l & mask;\n      carry = (l - m) * ipv;\n    }\n\n    if (carry === -1) {\n      limbs[i - 1] -= this.placeVal;\n    }\n\n    return this;\n  },\n  cnormalize: function cnormalize() {\n    var carry = 0,\n        i,\n        ipv = this.ipv,\n        l,\n        m,\n        limbs = this.limbs,\n        ll = limbs.length,\n        mask = this.radixMask;\n\n    for (i = 0; i < ll - 1; i++) {\n      l = limbs[i] + carry;\n      m = limbs[i] = l & mask;\n      carry = (l - m) * ipv;\n    }\n\n    limbs[i] += carry;\n    return this;\n  },\n  toBits: function toBits(len) {\n    this.fullReduce();\n    len = len || this.exponent || this.bitLength();\n    var i = Math.floor((len - 1) / 24),\n        w = sjcl.bitArray,\n        e = (len + 7 & -8) % this.radix || this.radix,\n        out = [w.partial(e, this.getLimb(i))];\n\n    for (i--; i >= 0; i--) {\n      out = w.concat(out, [w.partial(Math.min(this.radix, len), this.getLimb(i))]);\n      len -= this.radix;\n    }\n\n    return out;\n  },\n  bitLength: function bitLength() {\n    this.fullReduce();\n    var out = this.radix * (this.limbs.length - 1),\n        b = this.limbs[this.limbs.length - 1];\n\n    for (; b; b >>>= 1) {\n      out++;\n    }\n\n    return out + 7 & -8;\n  }\n};\n\nsjcl.bn.fromBits = function (bits) {\n  var Class = this,\n      out = new Class(),\n      words = [],\n      w = sjcl.bitArray,\n      t = this.prototype,\n      l = Math.min(this.bitLength || 0x100000000, w.bitLength(bits)),\n      e = l % t.radix || t.radix;\n  words[0] = w.extract(bits, 0, e);\n\n  for (; e < l; e += t.radix) {\n    words.unshift(w.extract(bits, e, t.radix));\n  }\n\n  out.limbs = words;\n  return out;\n};\n\nsjcl.bn.prototype.ipv = 1 / (sjcl.bn.prototype.placeVal = Math.pow(2, sjcl.bn.prototype.radix));\nsjcl.bn.prototype.radixMask = (1 << sjcl.bn.prototype.radix) - 1;\n\nsjcl.bn.pseudoMersennePrime = function (exponent, coeff) {\n  function p(it) {\n    this.initWith(it);\n  }\n\n  var ppr = p.prototype = new sjcl.bn(),\n      i,\n      tmp,\n      mo;\n  mo = ppr.modOffset = Math.ceil(tmp = exponent / ppr.radix);\n  ppr.exponent = exponent;\n  ppr.offset = [];\n  ppr.factor = [];\n  ppr.minOffset = mo;\n  ppr.fullMask = 0;\n  ppr.fullOffset = [];\n  ppr.fullFactor = [];\n  ppr.modulus = p.modulus = new sjcl.bn(Math.pow(2, exponent));\n  ppr.fullMask = 0 | -Math.pow(2, exponent % ppr.radix);\n\n  for (i = 0; i < coeff.length; i++) {\n    ppr.offset[i] = Math.floor(coeff[i][0] / ppr.radix - tmp);\n    ppr.fullOffset[i] = Math.ceil(coeff[i][0] / ppr.radix - tmp);\n    ppr.factor[i] = coeff[i][1] * Math.pow(1 / 2, exponent - coeff[i][0] + ppr.offset[i] * ppr.radix);\n    ppr.fullFactor[i] = coeff[i][1] * Math.pow(1 / 2, exponent - coeff[i][0] + ppr.fullOffset[i] * ppr.radix);\n    ppr.modulus.addM(new sjcl.bn(Math.pow(2, coeff[i][0]) * coeff[i][1]));\n    ppr.minOffset = Math.min(ppr.minOffset, -ppr.offset[i]);\n  }\n\n  ppr._class = p;\n  ppr.modulus.cnormalize();\n\n  ppr.reduce = function () {\n    var i,\n        k,\n        l,\n        mo = this.modOffset,\n        limbs = this.limbs,\n        aff,\n        off = this.offset,\n        ol = this.offset.length,\n        fac = this.factor,\n        ll;\n    i = this.minOffset;\n\n    while (limbs.length > mo) {\n      l = limbs.pop();\n      ll = limbs.length;\n\n      for (k = 0; k < ol; k++) {\n        limbs[ll + off[k]] -= fac[k] * l;\n      }\n\n      i--;\n\n      if (!i) {\n        limbs.push(0);\n        this.cnormalize();\n        i = this.minOffset;\n      }\n    }\n\n    this.cnormalize();\n    return this;\n  };\n\n  ppr._strongReduce = ppr.fullMask === -1 ? ppr.reduce : function () {\n    var limbs = this.limbs,\n        i = limbs.length - 1,\n        k,\n        l;\n    this.reduce();\n\n    if (i === this.modOffset - 1) {\n      l = limbs[i] & this.fullMask;\n      limbs[i] -= l;\n\n      for (k = 0; k < this.fullOffset.length; k++) {\n        limbs[i + this.fullOffset[k]] -= this.fullFactor[k] * l;\n      }\n\n      this.normalize();\n    }\n  };\n\n  ppr.fullReduce = function () {\n    var greater, i;\n\n    this._strongReduce();\n\n    this.addM(this.modulus);\n    this.addM(this.modulus);\n    this.normalize();\n\n    this._strongReduce();\n\n    for (i = this.limbs.length; i < this.modOffset; i++) {\n      this.limbs[i] = 0;\n    }\n\n    greater = this.greaterEquals(this.modulus);\n\n    for (i = 0; i < this.limbs.length; i++) {\n      this.limbs[i] -= this.modulus.limbs[i] * greater;\n    }\n\n    this.cnormalize();\n    return this;\n  };\n\n  ppr.inverse = function () {\n    return this.power(this.modulus.sub(2));\n  };\n\n  p.fromBits = sjcl.bn.fromBits;\n  return p;\n};\n\nsjcl.bn.prime = {\n  p127: sjcl.bn.pseudoMersennePrime(127, [[0, -1]]),\n  p25519: sjcl.bn.pseudoMersennePrime(255, [[0, -19]]),\n  p192: sjcl.bn.pseudoMersennePrime(192, [[0, -1], [64, -1]]),\n  p224: sjcl.bn.pseudoMersennePrime(224, [[0, 1], [96, -1]]),\n  p256: sjcl.bn.pseudoMersennePrime(256, [[0, -1], [96, 1], [192, 1], [224, -1]]),\n  p384: sjcl.bn.pseudoMersennePrime(384, [[0, -1], [32, 1], [96, -1], [128, -1]]),\n  p521: sjcl.bn.pseudoMersennePrime(521, [[0, -1]])\n};\n\nsjcl.bn.random = function (modulus, paranoia) {\n  if (typeof modulus !== \"object\") {\n    modulus = new sjcl.bn(modulus);\n  }\n\n  var words,\n      i,\n      l = modulus.limbs.length,\n      m = modulus.limbs[l - 1] + 1,\n      out = new sjcl.bn();\n\n  while (true) {\n    do {\n      words = sjcl.random.randomWords(l, paranoia);\n\n      if (words[l - 1] < 0) {\n        words[l - 1] += 0x100000000;\n      }\n    } while (Math.floor(words[l - 1] / m) === Math.floor(0x100000000 / m));\n\n    words[l - 1] %= m;\n\n    for (i = 0; i < l - 1; i++) {\n      words[i] &= modulus.radixMask;\n    }\n\n    out.limbs = words;\n\n    if (!out.greaterEquals(modulus)) {\n      return out;\n    }\n  }\n};\n\nsjcl.ecc = {};\n\nsjcl.ecc.point = function (curve, x, y) {\n  if (x === undefined) {\n    this.isIdentity = true;\n  } else {\n    if (x instanceof sjcl.bn) {\n      x = new curve.field(x);\n    }\n\n    if (y instanceof sjcl.bn) {\n      y = new curve.field(y);\n    }\n\n    this.x = x;\n    this.y = y;\n    this.isIdentity = false;\n  }\n\n  this.curve = curve;\n};\n\nsjcl.ecc.point.prototype = {\n  toJac: function toJac() {\n    return new sjcl.ecc.pointJac(this.curve, this.x, this.y, new this.curve.field(1));\n  },\n  mult: function mult(k) {\n    return this.toJac().mult(k, this).toAffine();\n  },\n  mult2: function mult2(k, k2, affine2) {\n    return this.toJac().mult2(k, this, k2, affine2).toAffine();\n  },\n  multiples: function multiples() {\n    var m, i, j;\n\n    if (this._multiples === undefined) {\n      j = this.toJac().doubl();\n      m = this._multiples = [new sjcl.ecc.point(this.curve), this, j.toAffine()];\n\n      for (i = 3; i < 16; i++) {\n        j = j.add(this);\n        m.push(j.toAffine());\n      }\n    }\n\n    return this._multiples;\n  },\n  isValid: function isValid() {\n    return this.y.square().equals(this.curve.b.add(this.x.mul(this.curve.a.add(this.x.square()))));\n  },\n  toBits: function toBits() {\n    return sjcl.bitArray.concat(this.x.toBits(), this.y.toBits());\n  }\n};\n\nsjcl.ecc.pointJac = function (curve, x, y, z) {\n  if (x === undefined) {\n    this.isIdentity = true;\n  } else {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n    this.isIdentity = false;\n  }\n\n  this.curve = curve;\n};\n\nsjcl.ecc.pointJac.prototype = {\n  add: function add(T) {\n    var S = this,\n        sz2,\n        c,\n        d,\n        c2,\n        x1,\n        x2,\n        x,\n        y1,\n        y2,\n        y,\n        z;\n\n    if (S.curve !== T.curve) {\n      throw \"sjcl.ecc.add(): Points must be on the same curve to add them!\";\n    }\n\n    if (S.isIdentity) {\n      return T.toJac();\n    } else if (T.isIdentity) {\n      return S;\n    }\n\n    sz2 = S.z.square();\n    c = T.x.mul(sz2).subM(S.x);\n\n    if (c.equals(0)) {\n      if (S.y.equals(T.y.mul(sz2.mul(S.z)))) {\n        return S.doubl();\n      } else {\n        return new sjcl.ecc.pointJac(S.curve);\n      }\n    }\n\n    d = T.y.mul(sz2.mul(S.z)).subM(S.y);\n    c2 = c.square();\n    x1 = d.square();\n    x2 = c.square().mul(c).addM(S.x.add(S.x).mul(c2));\n    x = x1.subM(x2);\n    y1 = S.x.mul(c2).subM(x).mul(d);\n    y2 = S.y.mul(c.square().mul(c));\n    y = y1.subM(y2);\n    z = S.z.mul(c);\n    return new sjcl.ecc.pointJac(this.curve, x, y, z);\n  },\n  doubl: function doubl() {\n    if (this.isIdentity) {\n      return this;\n    }\n\n    var y2 = this.y.square(),\n        a = y2.mul(this.x.mul(4)),\n        b = y2.square().mul(8),\n        z2 = this.z.square(),\n        c = this.x.sub(z2).mul(3).mul(this.x.add(z2)),\n        x = c.square().subM(a).subM(a),\n        y = a.sub(x).mul(c).subM(b),\n        z = this.y.add(this.y).mul(this.z);\n    return new sjcl.ecc.pointJac(this.curve, x, y, z);\n  },\n  toAffine: function toAffine() {\n    if (this.isIdentity || this.z.equals(0)) {\n      return new sjcl.ecc.point(this.curve);\n    }\n\n    var zi = this.z.inverse(),\n        zi2 = zi.square();\n    return new sjcl.ecc.point(this.curve, this.x.mul(zi2).fullReduce(), this.y.mul(zi2.mul(zi)).fullReduce());\n  },\n  mult: function mult(k, affine) {\n    if (typeof k === \"number\") {\n      k = [k];\n    } else if (k.limbs !== undefined) {\n      k = k.normalize().limbs;\n    }\n\n    var i,\n        j,\n        out = new sjcl.ecc.point(this.curve).toJac(),\n        multiples = affine.multiples();\n\n    for (i = k.length - 1; i >= 0; i--) {\n      for (j = sjcl.bn.prototype.radix - 4; j >= 0; j -= 4) {\n        out = out.doubl().doubl().doubl().doubl().add(multiples[k[i] >> j & 0xf]);\n      }\n    }\n\n    return out;\n  },\n  mult2: function mult2(k1, affine, k2, affine2) {\n    if (typeof k1 === \"number\") {\n      k1 = [k1];\n    } else if (k1.limbs !== undefined) {\n      k1 = k1.normalize().limbs;\n    }\n\n    if (typeof k2 === \"number\") {\n      k2 = [k2];\n    } else if (k2.limbs !== undefined) {\n      k2 = k2.normalize().limbs;\n    }\n\n    var i,\n        j,\n        out = new sjcl.ecc.point(this.curve).toJac(),\n        m1 = affine.multiples(),\n        m2 = affine2.multiples(),\n        l1,\n        l2;\n\n    for (i = Math.max(k1.length, k2.length) - 1; i >= 0; i--) {\n      l1 = k1[i] | 0;\n      l2 = k2[i] | 0;\n\n      for (j = sjcl.bn.prototype.radix - 4; j >= 0; j -= 4) {\n        out = out.doubl().doubl().doubl().doubl().add(m1[l1 >> j & 0xf]).add(m2[l2 >> j & 0xf]);\n      }\n    }\n\n    return out;\n  },\n  isValid: function isValid() {\n    var z2 = this.z.square(),\n        z4 = z2.square(),\n        z6 = z4.mul(z2);\n    return this.y.square().equals(this.curve.b.mul(z6).add(this.x.mul(this.curve.a.mul(z4).add(this.x.square()))));\n  }\n};\n\nsjcl.ecc.curve = function (Field, r, a, b, x, y) {\n  this.field = Field;\n  this.r = Field.prototype.modulus.sub(r);\n  this.a = new Field(a);\n  this.b = new Field(b);\n  this.G = new sjcl.ecc.point(this, new Field(x), new Field(y));\n};\n\nsjcl.ecc.curve.prototype.fromBits = function (bits) {\n  var w = sjcl.bitArray,\n      l = this.field.prototype.exponent + 7 & -8,\n      p = new sjcl.ecc.point(this, this.field.fromBits(w.bitSlice(bits, 0, l)), this.field.fromBits(w.bitSlice(bits, l, 2 * l)));\n\n  if (!p.isValid()) {\n    throw new sjcl.exception.corrupt(\"not on the curve!\");\n  }\n\n  return p;\n};\n\nsjcl.ecc.curves = {\n  c192: new sjcl.ecc.curve(sjcl.bn.prime.p192, \"0x662107c8eb94364e4b2dd7ce\", -3, \"0x64210519e59c80e70fa7e9ab72243049feb8deecc146b9b1\", \"0x188da80eb03090f67cbf20eb43a18800f4ff0afd82ff1012\", \"0x07192b95ffc8da78631011ed6b24cdd573f977a11e794811\"),\n  c224: new sjcl.ecc.curve(sjcl.bn.prime.p224, \"0xe95c1f470fc1ec22d6baa3a3d5c4\", -3, \"0xb4050a850c04b3abf54132565044b0b7d7bfd8ba270b39432355ffb4\", \"0xb70e0cbd6bb4bf7f321390b94a03c1d356c21122343280d6115c1d21\", \"0xbd376388b5f723fb4c22dfe6cd4375a05a07476444d5819985007e34\"),\n  c256: new sjcl.ecc.curve(sjcl.bn.prime.p256, \"0x4319055358e8617b0c46353d039cdaae\", -3, \"0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b\", \"0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296\", \"0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5\"),\n  c384: new sjcl.ecc.curve(sjcl.bn.prime.p384, \"0x389cb27e0bc8d21fa7e5f24cb74f58851313e696333ad68c\", -3, \"0xb3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aef\", \"0xaa87ca22be8b05378eb1c71ef320ad746e1d3b628ba79b9859f741e082542a385502f25dbf55296c3a545e3872760ab7\", \"0x3617de4a96262c6f5d9e98bf9292dc29f8f41dbd289a147ce9da3113b5f0b8c00a60b1ce1d7e819d7a431d7c90ea0e5f\")\n};\n\nsjcl.ecc._dh = function (cn) {\n  sjcl.ecc[cn] = {\n    publicKey: function publicKey(curve, point) {\n      this._curve = curve;\n      this._curveBitLength = curve.r.bitLength();\n\n      if (point instanceof Array) {\n        this._point = curve.fromBits(point);\n      } else {\n        this._point = point;\n      }\n\n      this.get = function () {\n        var pointbits = this._point.toBits();\n\n        var len = sjcl.bitArray.bitLength(pointbits);\n        var x = sjcl.bitArray.bitSlice(pointbits, 0, len / 2);\n        var y = sjcl.bitArray.bitSlice(pointbits, len / 2);\n        return {\n          x: x,\n          y: y\n        };\n      };\n    },\n    secretKey: function secretKey(curve, exponent) {\n      this._curve = curve;\n      this._curveBitLength = curve.r.bitLength();\n      this._exponent = exponent;\n\n      this.get = function () {\n        return this._exponent.toBits();\n      };\n    },\n    generateKeys: function generateKeys(curve, paranoia, sec) {\n      if (curve === undefined) {\n        curve = 256;\n      }\n\n      if (typeof curve === \"number\") {\n        curve = sjcl.ecc.curves[\"c\" + curve];\n\n        if (curve === undefined) {\n          throw new sjcl.exception.invalid(\"no such curve\");\n        }\n      }\n\n      if (sec === undefined) {\n        var sec = sjcl.bn.random(curve.r, paranoia);\n      }\n\n      var pub = curve.G.mult(sec);\n      return {\n        pub: new sjcl.ecc[cn].publicKey(curve, pub),\n        sec: new sjcl.ecc[cn].secretKey(curve, sec)\n      };\n    }\n  };\n};\n\nsjcl.ecc._dh(\"elGamal\");\n\nsjcl.ecc.elGamal.publicKey.prototype = {\n  kem: function kem(paranoia) {\n    var sec = sjcl.bn.random(this._curve.r, paranoia),\n        tag = this._curve.G.mult(sec).toBits(),\n        key = sjcl.hash.sha256.hash(this._point.mult(sec).toBits());\n\n    return {\n      key: key,\n      tag: tag\n    };\n  }\n};\nsjcl.ecc.elGamal.secretKey.prototype = {\n  unkem: function unkem(tag) {\n    return sjcl.hash.sha256.hash(this._curve.fromBits(tag).mult(this._exponent).toBits());\n  },\n  dh: function dh(pk) {\n    return sjcl.hash.sha256.hash(pk._point.mult(this._exponent).toBits());\n  }\n};\n\nsjcl.ecc._dh(\"ecdsa\");\n\nsjcl.ecc.ecdsa.secretKey.prototype = {\n  sign: function sign(hash, paranoia, fakeLegacyVersion, fixedKForTesting) {\n    if (sjcl.bitArray.bitLength(hash) > this._curveBitLength) {\n      hash = sjcl.bitArray.clamp(hash, this._curveBitLength);\n    }\n\n    var R = this._curve.r,\n        l = R.bitLength(),\n        k = fixedKForTesting || sjcl.bn.random(R.sub(1), paranoia).add(1),\n        r = this._curve.G.mult(k).x.mod(R),\n        ss = sjcl.bn.fromBits(hash).add(r.mul(this._exponent)),\n        s = fakeLegacyVersion ? ss.inverseMod(R).mul(k).mod(R) : ss.mul(k.inverseMod(R)).mod(R);\n\n    return sjcl.bitArray.concat(r.toBits(l), s.toBits(l));\n  }\n};\nsjcl.ecc.ecdsa.publicKey.prototype = {\n  verify: function verify(hash, rs, fakeLegacyVersion) {\n    if (sjcl.bitArray.bitLength(hash) > this._curveBitLength) {\n      hash = sjcl.bitArray.clamp(hash, this._curveBitLength);\n    }\n\n    var w = sjcl.bitArray,\n        R = this._curve.r,\n        l = this._curveBitLength,\n        r = sjcl.bn.fromBits(w.bitSlice(rs, 0, l)),\n        ss = sjcl.bn.fromBits(w.bitSlice(rs, l, 2 * l)),\n        s = fakeLegacyVersion ? ss : ss.inverseMod(R),\n        hG = sjcl.bn.fromBits(hash).mul(s).mod(R),\n        hA = r.mul(s).mod(R),\n        r2 = this._curve.G.mult2(hG, hA, this._point).x;\n\n    if (r.equals(0) || ss.equals(0) || r.greaterEquals(R) || ss.greaterEquals(R) || !r2.equals(r)) {\n      if (fakeLegacyVersion === undefined) {\n        return this.verify(hash, rs, true);\n      } else {\n        throw new sjcl.exception.corrupt(\"signature didn't check out\");\n      }\n    }\n\n    return true;\n  }\n};\nsjcl.keyexchange.srp = {\n  makeVerifier: function makeVerifier(I, P, s, group) {\n    var x;\n    x = sjcl.keyexchange.srp.makeX(I, P, s);\n    x = sjcl.bn.fromBits(x);\n    return group.g.powermod(x, group.N);\n  },\n  makeX: function makeX(I, P, s) {\n    var inner = sjcl.hash.sha1.hash(I + \":\" + P);\n    return sjcl.hash.sha1.hash(sjcl.bitArray.concat(s, inner));\n  },\n  knownGroup: function knownGroup(i) {\n    if (typeof i !== \"string\") {\n      i = i.toString();\n    }\n\n    if (!sjcl.keyexchange.srp._didInitKnownGroups) {\n      sjcl.keyexchange.srp._initKnownGroups();\n    }\n\n    return sjcl.keyexchange.srp._knownGroups[i];\n  },\n  _didInitKnownGroups: false,\n  _initKnownGroups: function _initKnownGroups() {\n    var i, size, group;\n\n    for (i = 0; i < sjcl.keyexchange.srp._knownGroupSizes.length; i++) {\n      size = sjcl.keyexchange.srp._knownGroupSizes[i].toString();\n      group = sjcl.keyexchange.srp._knownGroups[size];\n      group.N = new sjcl.bn(group.N);\n      group.g = new sjcl.bn(group.g);\n    }\n\n    sjcl.keyexchange.srp._didInitKnownGroups = true;\n  },\n  _knownGroupSizes: [1024, 1536, 2048],\n  _knownGroups: {\n    1024: {\n      N: \"EEAF0AB9ADB38DD69C33F80AFA8FC5E86072618775FF3C0B9EA2314C\" + \"9C256576D674DF7496EA81D3383B4813D692C6E0E0D5D8E250B98BE4\" + \"8E495C1D6089DAD15DC7D7B46154D6B6CE8EF4AD69B15D4982559B29\" + \"7BCF1885C529F566660E57EC68EDBC3C05726CC02FD4CBF4976EAA9A\" + \"FD5138FE8376435B9FC61D2FC0EB06E3\",\n      g: 2\n    },\n    1536: {\n      N: \"9DEF3CAFB939277AB1F12A8617A47BBBDBA51DF499AC4C80BEEEA961\" + \"4B19CC4D5F4F5F556E27CBDE51C6A94BE4607A291558903BA0D0F843\" + \"80B655BB9A22E8DCDF028A7CEC67F0D08134B1C8B97989149B609E0B\" + \"E3BAB63D47548381DBC5B1FC764E3F4B53DD9DA1158BFD3E2B9C8CF5\" + \"6EDF019539349627DB2FD53D24B7C48665772E437D6C7F8CE442734A\" + \"F7CCB7AE837C264AE3A9BEB87F8A2FE9B8B5292E5A021FFF5E91479E\" + \"8CE7A28C2442C6F315180F93499A234DCF76E3FED135F9BB\",\n      g: 2\n    },\n    2048: {\n      N: \"AC6BDB41324A9A9BF166DE5E1389582FAF72B6651987EE07FC319294\" + \"3DB56050A37329CBB4A099ED8193E0757767A13DD52312AB4B03310D\" + \"CD7F48A9DA04FD50E8083969EDB767B0CF6095179A163AB3661A05FB\" + \"D5FAAAE82918A9962F0B93B855F97993EC975EEAA80D740ADBF4FF74\" + \"7359D041D5C33EA71D281E446B14773BCA97B43A23FB801676BD207A\" + \"436C6481F1D2B9078717461A5B9D32E688F87748544523B524B0D57D\" + \"5EA77A2775D2ECFA032CFBDBF52FB3786160279004E57AE6AF874E73\" + \"03CE53299CCC041C7BC308D82A5698F3A8D0C38271AE35F8E9DBFBB6\" + \"94B5C803D89F7AE435DE236D525F54759B65E372FCD68EF20FA7111F\" + \"9E4AFF73\",\n      g: 2\n    }\n  }\n};\n\nsjcl.ecc.point.prototype.isValidPoint = function () {\n  var self = this;\n  var field_modulus = self.curve.field.modulus;\n\n  if (self.isIdentity) {\n    return false;\n  }\n\n  if (new sjcl.bn(1).greaterEquals(self.x) && !self.x.equals(1) || self.x.greaterEquals(field_modulus.sub(1)) && !self.x.equals(1)) {\n    return false;\n  }\n\n  if (new sjcl.bn(1).greaterEquals(self.y) && !self.y.equals(1) || self.y.greaterEquals(field_modulus.sub(1)) && !self.y.equals(1)) {\n    return false;\n  }\n\n  if (!self.isOnCurve()) {\n    return false;\n  }\n\n  return true;\n};\n\nsjcl.ecc.point.prototype.isOnCurve = function () {\n  var self = this;\n  var field_order = self.curve.r;\n  var component_a = self.curve.a;\n  var component_b = self.curve.b;\n  var field_modulus = self.curve.field.modulus;\n  var left_hand_side = self.y.mul(self.y).mod(field_modulus);\n  var right_hand_side = self.x.mul(self.x).mul(self.x).add(component_a.mul(self.x)).add(component_b).mod(field_modulus);\n  return left_hand_side.equals(right_hand_side);\n};\n\nsjcl.ecc.point.prototype.toString = function () {\n  return \"(\" + this.x.toString() + \", \" + this.y.toString() + \")\";\n};\n\nsjcl.ecc.pointJac.prototype.toString = function () {\n  return \"(\" + this.x.toString() + \", \" + this.y.toString() + \", \" + this.z.toString() + \")\";\n};\n\nsjcl.ecc.curves.c256 = new sjcl.ecc.curve(sjcl.bn.pseudoMersennePrime(256, [[0, -1], [4, -1], [6, -1], [7, -1], [8, -1], [9, -1], [32, -1]]), \"0x14551231950b75fc4402da1722fc9baee\", 0, 7, \"0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798\", \"0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8\");\n\nsjcl.ecc.pointJac.prototype.add = function (T) {\n  var S = this;\n\n  if (S.curve !== T.curve) {\n    throw \"sjcl.ecc.add(): Points must be on the same curve to add them!\";\n  }\n\n  if (S.isIdentity) {\n    return T.toJac();\n  } else if (T.isIdentity) {\n    return S;\n  }\n\n  var z1z1 = S.z.square();\n  var h = T.x.mul(z1z1).subM(S.x);\n  var s2 = T.y.mul(S.z).mul(z1z1);\n\n  if (h.equals(0)) {\n    if (S.y.equals(T.y.mul(z1z1.mul(S.z)))) {\n      return S.doubl();\n    } else {\n      return new sjcl.ecc.pointJac(S.curve);\n    }\n  }\n\n  var hh = h.square();\n  var i = hh.copy().doubleM().doubleM();\n  var j = h.mul(i);\n  var r = s2.sub(S.y).doubleM();\n  var v = S.x.mul(i);\n  var x = r.square().subM(j).subM(v.copy().doubleM());\n  var y = r.mul(v.sub(x)).subM(S.y.mul(j).doubleM());\n  var z = S.z.add(h).square().subM(z1z1).subM(hh);\n  return new sjcl.ecc.pointJac(this.curve, x, y, z);\n};\n\nsjcl.ecc.pointJac.prototype.doubl = function () {\n  if (this.isIdentity) {\n    return this;\n  }\n\n  var a = this.x.square();\n  var b = this.y.square();\n  var c = b.square();\n  var d = this.x.add(b).square().subM(a).subM(c).doubleM();\n  var e = a.mul(3);\n  var f = e.square();\n  var x = f.sub(d.copy().doubleM());\n  var y = e.mul(d.sub(x)).subM(c.doubleM().doubleM().doubleM());\n  var z = this.z.mul(this.y).doubleM();\n  return new sjcl.ecc.pointJac(this.curve, x, y, z);\n};\n\nsjcl.ecc.point.prototype.toBytesCompressed = function () {\n  var header = this.y.mod(2).toString() == \"0x0\" ? 0x02 : 0x03;\n  return [header].concat(sjcl.codec.bytes.fromBits(this.x.toBits()));\n};\n\n(function () {\n  sjcl.hash.ripemd160 = function (hash) {\n    if (hash) {\n      this._h = hash._h.slice(0);\n      this._buffer = hash._buffer.slice(0);\n      this._length = hash._length;\n    } else {\n      this.reset();\n    }\n  };\n\n  sjcl.hash.ripemd160.hash = function (data) {\n    return new sjcl.hash.ripemd160().update(data).finalize();\n  };\n\n  sjcl.hash.ripemd160.prototype = {\n    reset: function reset() {\n      this._h = _h0.slice(0);\n      this._buffer = [];\n      this._length = 0;\n      return this;\n    },\n    update: function update(data) {\n      if (typeof data === \"string\") data = sjcl.codec.utf8String.toBits(data);\n      var i,\n          b = this._buffer = sjcl.bitArray.concat(this._buffer, data),\n          ol = this._length,\n          nl = this._length = ol + sjcl.bitArray.bitLength(data);\n\n      for (i = 512 + ol & -512; i <= nl; i += 512) {\n        var words = b.splice(0, 16);\n\n        for (var w = 0; w < 16; ++w) {\n          words[w] = _cvt(words[w]);\n        }\n\n        _block.call(this, words);\n      }\n\n      return this;\n    },\n    finalize: function finalize() {\n      var b = sjcl.bitArray.concat(this._buffer, [sjcl.bitArray.partial(1, 1)]),\n          l = (this._length + 1) % 512,\n          z = (l > 448 ? 512 : 448) - l % 448,\n          zp = z % 32;\n      if (zp > 0) b = sjcl.bitArray.concat(b, [sjcl.bitArray.partial(zp, 0)]);\n\n      for (; z >= 32; z -= 32) {\n        b.push(0);\n      }\n\n      b.push(_cvt(this._length | 0));\n      b.push(_cvt(Math.floor(this._length / 0x100000000)));\n\n      while (b.length) {\n        var words = b.splice(0, 16);\n\n        for (var w = 0; w < 16; ++w) {\n          words[w] = _cvt(words[w]);\n        }\n\n        _block.call(this, words);\n      }\n\n      var h = this._h;\n      this.reset();\n\n      for (var w = 0; w < 5; ++w) {\n        h[w] = _cvt(h[w]);\n      }\n\n      return h;\n    }\n  };\n  var _h0 = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];\n  var _k1 = [0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e];\n  var _k2 = [0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000];\n\n  for (var i = 4; i >= 0; --i) {\n    for (var j = 1; j < 16; ++j) {\n      _k1.splice(i, 0, _k1[i]);\n\n      _k2.splice(i, 0, _k2[i]);\n    }\n  }\n\n  var _r1 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13];\n  var _r2 = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11];\n  var _s1 = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6];\n  var _s2 = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11];\n\n  function _f0(x, y, z) {\n    return x ^ y ^ z;\n  }\n\n  function _f1(x, y, z) {\n    return x & y | ~x & z;\n  }\n\n  function _f2(x, y, z) {\n    return (x | ~y) ^ z;\n  }\n\n  function _f3(x, y, z) {\n    return x & z | y & ~z;\n  }\n\n  function _f4(x, y, z) {\n    return x ^ (y | ~z);\n  }\n\n  function _rol(n, l) {\n    return n << l | n >>> 32 - l;\n  }\n\n  function _cvt(n) {\n    return (n & 0xff << 0) << 24 | (n & 0xff << 8) << 8 | (n & 0xff << 16) >>> 8 | (n & 0xff << 24) >>> 24;\n  }\n\n  function _block(X) {\n    var A1 = this._h[0],\n        B1 = this._h[1],\n        C1 = this._h[2],\n        D1 = this._h[3],\n        E1 = this._h[4],\n        A2 = this._h[0],\n        B2 = this._h[1],\n        C2 = this._h[2],\n        D2 = this._h[3],\n        E2 = this._h[4];\n    var j = 0,\n        T;\n\n    for (; j < 16; ++j) {\n      T = _rol(A1 + _f0(B1, C1, D1) + X[_r1[j]] + _k1[j], _s1[j]) + E1;\n      A1 = E1;\n      E1 = D1;\n      D1 = _rol(C1, 10);\n      C1 = B1;\n      B1 = T;\n      T = _rol(A2 + _f4(B2, C2, D2) + X[_r2[j]] + _k2[j], _s2[j]) + E2;\n      A2 = E2;\n      E2 = D2;\n      D2 = _rol(C2, 10);\n      C2 = B2;\n      B2 = T;\n    }\n\n    for (; j < 32; ++j) {\n      T = _rol(A1 + _f1(B1, C1, D1) + X[_r1[j]] + _k1[j], _s1[j]) + E1;\n      A1 = E1;\n      E1 = D1;\n      D1 = _rol(C1, 10);\n      C1 = B1;\n      B1 = T;\n      T = _rol(A2 + _f3(B2, C2, D2) + X[_r2[j]] + _k2[j], _s2[j]) + E2;\n      A2 = E2;\n      E2 = D2;\n      D2 = _rol(C2, 10);\n      C2 = B2;\n      B2 = T;\n    }\n\n    for (; j < 48; ++j) {\n      T = _rol(A1 + _f2(B1, C1, D1) + X[_r1[j]] + _k1[j], _s1[j]) + E1;\n      A1 = E1;\n      E1 = D1;\n      D1 = _rol(C1, 10);\n      C1 = B1;\n      B1 = T;\n      T = _rol(A2 + _f2(B2, C2, D2) + X[_r2[j]] + _k2[j], _s2[j]) + E2;\n      A2 = E2;\n      E2 = D2;\n      D2 = _rol(C2, 10);\n      C2 = B2;\n      B2 = T;\n    }\n\n    for (; j < 64; ++j) {\n      T = _rol(A1 + _f3(B1, C1, D1) + X[_r1[j]] + _k1[j], _s1[j]) + E1;\n      A1 = E1;\n      E1 = D1;\n      D1 = _rol(C1, 10);\n      C1 = B1;\n      B1 = T;\n      T = _rol(A2 + _f1(B2, C2, D2) + X[_r2[j]] + _k2[j], _s2[j]) + E2;\n      A2 = E2;\n      E2 = D2;\n      D2 = _rol(C2, 10);\n      C2 = B2;\n      B2 = T;\n    }\n\n    for (; j < 80; ++j) {\n      T = _rol(A1 + _f4(B1, C1, D1) + X[_r1[j]] + _k1[j], _s1[j]) + E1;\n      A1 = E1;\n      E1 = D1;\n      D1 = _rol(C1, 10);\n      C1 = B1;\n      B1 = T;\n      T = _rol(A2 + _f0(B2, C2, D2) + X[_r2[j]] + _k2[j], _s2[j]) + E2;\n      A2 = E2;\n      E2 = D2;\n      D2 = _rol(C2, 10);\n      C2 = B2;\n      B2 = T;\n    }\n\n    T = this._h[1] + C1 + D2;\n    this._h[1] = this._h[2] + D1 + E2;\n    this._h[2] = this._h[3] + E1 + A2;\n    this._h[3] = this._h[4] + A1 + B2;\n    this._h[4] = this._h[0] + B1 + C2;\n    this._h[0] = T;\n  }\n})();\n\nsjcl.bn.ZERO = new sjcl.bn(0);\n\nsjcl.bn.prototype.divRem = function (that) {\n  if (typeof that !== \"object\") {\n    that = new this._class(that);\n  }\n\n  var thisa = this.abs(),\n      thata = that.abs(),\n      quot = new this._class(0),\n      ci = 0;\n\n  if (!thisa.greaterEquals(thata)) {\n    return [new sjcl.bn(0), this.copy()];\n  } else if (thisa.equals(thata)) {\n    return [new sjcl.bn(1), new sjcl.bn(0)];\n  }\n\n  for (; thisa.greaterEquals(thata); ci++) {\n    thata.doubleM();\n  }\n\n  for (; ci > 0; ci--) {\n    quot.doubleM();\n    thata.halveM();\n\n    if (thisa.greaterEquals(thata)) {\n      quot.addM(1);\n      thisa.subM(that).normalize();\n    }\n  }\n\n  return [quot, thisa];\n};\n\nsjcl.bn.prototype.divRound = function (that) {\n  var dr = this.divRem(that),\n      quot = dr[0],\n      rem = dr[1];\n\n  if (rem.doubleM().greaterEquals(that)) {\n    quot.addM(1);\n  }\n\n  return quot;\n};\n\nsjcl.bn.prototype.div = function (that) {\n  var dr = this.divRem(that);\n  return dr[0];\n};\n\nsjcl.bn.prototype.sign = function () {\n  return this.greaterEquals(sjcl.bn.ZERO) ? 1 : -1;\n};\n\nsjcl.bn.prototype.neg = function () {\n  return sjcl.bn.ZERO.sub(this);\n};\n\nsjcl.bn.prototype.abs = function () {\n  if (this.sign() === -1) {\n    return this.neg();\n  } else return this;\n};\n\nsjcl.bn.prototype.shiftRight = function (that) {\n  if (\"number\" !== typeof that) {\n    throw new Error(\"shiftRight expects a number\");\n  }\n\n  that = +that;\n\n  if (that < 0) {\n    return this.shiftLeft(that);\n  }\n\n  var a = new sjcl.bn(this);\n\n  while (that >= this.radix) {\n    a.limbs.shift();\n    that -= this.radix;\n  }\n\n  while (that--) {\n    a.halveM();\n  }\n\n  return a;\n};\n\nsjcl.bn.prototype.shiftLeft = function (that) {\n  if (\"number\" !== typeof that) {\n    throw new Error(\"shiftLeft expects a number\");\n  }\n\n  that = +that;\n\n  if (that < 0) {\n    return this.shiftRight(that);\n  }\n\n  var a = new sjcl.bn(this);\n\n  while (that >= this.radix) {\n    a.limbs.unshift(0);\n    that -= this.radix;\n  }\n\n  while (that--) {\n    a.doubleM();\n  }\n\n  return a;\n};\n\nsjcl.bn.prototype.toNumber = function () {\n  return this.limbs[0] | 0;\n};\n\nsjcl.bn.prototype.testBit = function (bitIndex) {\n  var limbIndex = Math.floor(bitIndex / this.radix);\n  var bitIndexInLimb = bitIndex % this.radix;\n  if (limbIndex >= this.limbs.length) return 0;\n  return this.limbs[limbIndex] >>> bitIndexInLimb & 1;\n};\n\nsjcl.bn.prototype.setBitM = function (bitIndex) {\n  var limbIndex = Math.floor(bitIndex / this.radix);\n  var bitIndexInLimb = bitIndex % this.radix;\n\n  while (limbIndex >= this.limbs.length) {\n    this.limbs.push(0);\n  }\n\n  this.limbs[limbIndex] |= 1 << bitIndexInLimb;\n  this.cnormalize();\n  return this;\n};\n\nsjcl.bn.prototype.modInt = function (n) {\n  return this.toNumber() % n;\n};\n\nsjcl.bn.prototype.invDigit = function () {\n  var radixMod = 1 + this.radixMask;\n  if (this.limbs.length < 1) return 0;\n  var x = this.limbs[0];\n  if ((x & 1) == 0) return 0;\n  var y = x & 3;\n  y = y * (2 - (x & 0xf) * y) & 0xf;\n  y = y * (2 - (x & 0xff) * y) & 0xff;\n  y = y * (2 - ((x & 0xffff) * y & 0xffff)) & 0xffff;\n  y = y * (2 - x * y % radixMod) % radixMod;\n  return y > 0 ? radixMod - y : -y;\n};\n\nfunction nbits(x) {\n  var r = 1,\n      t;\n\n  if ((t = x >>> 16) != 0) {\n    x = t;\n    r += 16;\n  }\n\n  if ((t = x >> 8) != 0) {\n    x = t;\n    r += 8;\n  }\n\n  if ((t = x >> 4) != 0) {\n    x = t;\n    r += 4;\n  }\n\n  if ((t = x >> 2) != 0) {\n    x = t;\n    r += 2;\n  }\n\n  if ((t = x >> 1) != 0) {\n    x = t;\n    r += 1;\n  }\n\n  return r;\n}\n\nsjcl.bn.prototype.am = function (i, x, w, j, c, n) {\n  var xl = x & 0xfff,\n      xh = x >> 12;\n\n  while (--n >= 0) {\n    var l = this.limbs[i] & 0xfff;\n    var h = this.limbs[i++] >> 12;\n    var m = xh * l + h * xl;\n    l = xl * l + ((m & 0xfff) << 12) + w.limbs[j] + c;\n    c = (l >> 24) + (m >> 12) + xh * h;\n    w.limbs[j++] = l & 0xffffff;\n  }\n\n  return c;\n};\n\nvar Montgomery = function Montgomery(m) {\n  this.m = m;\n  this.mt = m.limbs.length;\n  this.mt2 = this.mt * 2;\n  this.mp = m.invDigit();\n  this.mpl = this.mp & 0x7fff;\n  this.mph = this.mp >> 15;\n  this.um = (1 << m.radix - 15) - 1;\n};\n\nMontgomery.prototype.reduce = function (x) {\n  var radixMod = x.radixMask + 1;\n\n  while (x.limbs.length <= this.mt2) {\n    x.limbs[x.limbs.length] = 0;\n  }\n\n  for (var i = 0; i < this.mt; ++i) {\n    var j = x.limbs[i] & 0x7fff;\n    var u0 = j * this.mpl + ((j * this.mph + (x.limbs[i] >> 15) * this.mpl & this.um) << 15) & x.radixMask;\n    j = i + this.mt;\n    x.limbs[j] += this.m.am(0, u0, x, i, 0, this.mt);\n\n    while (x.limbs[j] >= radixMod) {\n      x.limbs[j] -= radixMod;\n      x.limbs[++j]++;\n    }\n  }\n\n  x.trim();\n  x = x.shiftRight(this.mt * this.m.radix);\n  if (x.greaterEquals(this.m)) x = x.sub(this.m);\n  return x.trim().normalize().reduce();\n};\n\nMontgomery.prototype.square = function (x) {\n  return this.reduce(x.square());\n};\n\nMontgomery.prototype.multiply = function (x, y) {\n  return this.reduce(x.mul(y));\n};\n\nMontgomery.prototype.convert = function (x) {\n  return x.abs().shiftLeft(this.mt * this.m.radix).mod(this.m);\n};\n\nMontgomery.prototype.revert = function (x) {\n  return this.reduce(x.copy());\n};\n\nsjcl.bn.prototype.powermodMontgomery = function (e, m) {\n  var i = e.bitLength(),\n      k,\n      r = new this._class(1);\n  if (i <= 0) return r;else if (i < 18) k = 1;else if (i < 48) k = 3;else if (i < 144) k = 4;else if (i < 768) k = 5;else k = 6;\n\n  if (i < 8 || !m.testBit(0)) {\n    return this.powermod(e, m);\n  }\n\n  var z = new Montgomery(m);\n  e.trim().normalize();\n  var g = new Array(),\n      n = 3,\n      k1 = k - 1,\n      km = (1 << k) - 1;\n  g[1] = z.convert(this);\n\n  if (k > 1) {\n    var g2 = z.square(g[1]);\n\n    while (n <= km) {\n      g[n] = z.multiply(g2, g[n - 2]);\n      n += 2;\n    }\n  }\n\n  var j = e.limbs.length - 1,\n      w,\n      is1 = true,\n      r2 = new this._class(),\n      t;\n  i = nbits(e.limbs[j]) - 1;\n\n  while (j >= 0) {\n    if (i >= k1) w = e.limbs[j] >> i - k1 & km;else {\n      w = (e.limbs[j] & (1 << i + 1) - 1) << k1 - i;\n      if (j > 0) w |= e.limbs[j - 1] >> this.radix + i - k1;\n    }\n    n = k;\n\n    while ((w & 1) == 0) {\n      w >>= 1;\n      --n;\n    }\n\n    if ((i -= n) < 0) {\n      i += this.radix;\n      --j;\n    }\n\n    if (is1) {\n      r = g[w].copy();\n      is1 = false;\n    } else {\n      while (n > 1) {\n        r2 = z.square(r);\n        r = z.square(r2);\n        n -= 2;\n      }\n\n      if (n > 0) r2 = z.square(r);else {\n        t = r;\n        r = r2;\n        r2 = t;\n      }\n      r = z.multiply(r2, g[w]);\n    }\n\n    while (j >= 0 && (e.limbs[j] & 1 << i) == 0) {\n      r2 = z.square(r);\n      t = r;\n      r = r2;\n      r2 = t;\n\n      if (--i < 0) {\n        i = this.radix - 1;\n        --j;\n      }\n    }\n  }\n\n  return z.revert(r);\n};\n\nsjcl.ecc.ecdsa.secretKey.prototype.sign = function (hash, paranoia, k_for_testing) {\n  var R = this._curve.r,\n      l = R.bitLength();\n  var k;\n\n  if (typeof k_for_testing === \"object\" && k_for_testing.length > 0 && typeof k_for_testing[0] === \"number\") {\n    k = k_for_testing;\n  } else if (typeof k_for_testing === \"string\" && /^[0-9a-fA-F]+$/.test(k_for_testing)) {\n    k = sjcl.bn.fromBits(sjcl.codec.hex.toBits(k_for_testing));\n  } else {\n    k = sjcl.bn.random(R.sub(1), paranoia).add(1);\n  }\n\n  var r = this._curve.G.mult(k).x.mod(R);\n\n  var s = sjcl.bn.fromBits(hash).add(r.mul(this._exponent)).mul(k.inverseMod(R)).mod(R);\n  return sjcl.bitArray.concat(r.toBits(l), s.toBits(l));\n};\n\nsjcl.ecc.ecdsa.publicKey.prototype.verify = function (hash, rs) {\n  var w = sjcl.bitArray,\n      R = this._curve.r,\n      l = R.bitLength(),\n      r = sjcl.bn.fromBits(w.bitSlice(rs, 0, l)),\n      s = sjcl.bn.fromBits(w.bitSlice(rs, l, 2 * l)),\n      sInv = s.inverseMod(R),\n      hG = sjcl.bn.fromBits(hash).mul(sInv).mod(R),\n      hA = r.mul(sInv).mod(R),\n      r2 = this._curve.G.mult2(hG, hA, this._point).x;\n\n  if (r.equals(0) || s.equals(0) || r.greaterEquals(R) || s.greaterEquals(R) || !r2.equals(r)) {\n    throw new sjcl.exception.corrupt(\"signature didn't check out\");\n  }\n\n  return true;\n};\n\nsjcl.ecc.ecdsa.secretKey.prototype.canonicalizeSignature = function (rs) {\n  var w = sjcl.bitArray,\n      R = this._curve.r,\n      l = R.bitLength();\n  var r = sjcl.bn.fromBits(w.bitSlice(rs, 0, l)),\n      s = sjcl.bn.fromBits(w.bitSlice(rs, l, 2 * l));\n\n  if (!R.copy().halveM().greaterEquals(s)) {\n    s = R.sub(s);\n  }\n\n  return w.concat(r.toBits(l), s.toBits(l));\n};\n\nsjcl.ecc.ecdsa.secretKey.prototype.signDER = function (hash, paranoia) {\n  return this.encodeDER(this.sign(hash, paranoia));\n};\n\nsjcl.ecc.ecdsa.secretKey.prototype.encodeDER = function (rs) {\n  var w = sjcl.bitArray,\n      R = this._curve.r,\n      l = R.bitLength();\n  var rb = sjcl.codec.bytes.fromBits(w.bitSlice(rs, 0, l)),\n      sb = sjcl.codec.bytes.fromBits(w.bitSlice(rs, l, 2 * l));\n\n  while (!rb[0] && rb.length) {\n    rb.shift();\n  }\n\n  while (!sb[0] && sb.length) {\n    sb.shift();\n  }\n\n  if (rb[0] & 0x80) rb.unshift(0);\n  if (sb[0] & 0x80) sb.unshift(0);\n  var buffer = [].concat(0x30, 4 + rb.length + sb.length, 0x02, rb.length, rb, 0x02, sb.length, sb);\n  return sjcl.codec.bytes.toBits(buffer);\n};\n\nvar FIELD_MODULUS_PLUS_ONE_DIVIDED_BY_FOUR;\n\nsjcl.ecc.ecdsa.secretKey.prototype.signWithRecoverablePublicKey = function (hash, paranoia, k_for_testing) {\n  var self = this;\n  var hash_bits;\n\n  if (typeof hash === \"object\" && hash.length > 0 && typeof hash[0] === \"number\") {\n    hash_bits = hash;\n  } else {\n    throw new sjcl.exception.invalid(\"hash. Must be a bitArray\");\n  }\n\n  var standard_signature = self.sign(hash_bits, paranoia, k_for_testing);\n  var canonical_signature = self.canonicalizeSignature(standard_signature);\n  var r_and_s = getRandSFromSignature(self._curve, canonical_signature);\n\n  var public_key = self._curve.G.mult(sjcl.bn.fromBits(self.get()));\n\n  var recovery_factor = calculateRecoveryFactor(self._curve, r_and_s.r, r_and_s.s, hash_bits, public_key);\n  var value_to_prepend = recovery_factor + 27;\n  var final_signature_bits = sjcl.bitArray.concat([value_to_prepend], canonical_signature);\n  return final_signature_bits;\n};\n\nsjcl.ecc.ecdsa.publicKey.recoverFromSignature = function (hash, signature, curve) {\n  if (!signature || signature instanceof sjcl.ecc.curve) {\n    throw new sjcl.exception.invalid(\"must supply hash and signature to recover public key\");\n  }\n\n  if (!curve) {\n    curve = sjcl.ecc.curves[\"c256\"];\n  }\n\n  var hash_bits;\n\n  if (typeof hash === \"object\" && hash.length > 0 && typeof hash[0] === \"number\") {\n    hash_bits = hash;\n  } else {\n    throw new sjcl.exception.invalid(\"hash. Must be a bitArray\");\n  }\n\n  var signature_bits;\n\n  if (typeof signature === \"object\" && signature.length > 0 && typeof signature[0] === \"number\") {\n    signature_bits = signature;\n  } else {\n    throw new sjcl.exception.invalid(\"signature. Must be a bitArray\");\n  }\n\n  var recovery_factor = signature_bits[0] - 27;\n\n  if (recovery_factor < 0 || recovery_factor > 3) {\n    throw new sjcl.exception.invalid(\"signature. Signature must be generated with algorithm \" + \"that prepends the recovery factor in order to recover the public key\");\n  }\n\n  var r_and_s = getRandSFromSignature(curve, signature_bits.slice(1));\n  var signature_r = r_and_s.r;\n  var signature_s = r_and_s.s;\n  var recovered_public_key_point = recoverPublicKeyPointFromSignature(curve, signature_r, signature_s, hash_bits, recovery_factor);\n  var recovered_public_key = new sjcl.ecc.ecdsa.publicKey(curve, recovered_public_key_point);\n  return recovered_public_key;\n};\n\nfunction getRandSFromSignature(curve, signature) {\n  var r_length = curve.r.bitLength();\n  return {\n    r: sjcl.bn.fromBits(sjcl.bitArray.bitSlice(signature, 0, r_length)),\n    s: sjcl.bn.fromBits(sjcl.bitArray.bitSlice(signature, r_length, sjcl.bitArray.bitLength(signature)))\n  };\n}\n\nfunction calculateRecoveryFactor(curve, r, s, hash_bits, original_public_key_point) {\n  var original_public_key_point_bits = original_public_key_point.toBits();\n\n  for (var possible_factor = 0; possible_factor < 4; possible_factor++) {\n    var resulting_public_key_point;\n\n    try {\n      resulting_public_key_point = recoverPublicKeyPointFromSignature(curve, r, s, hash_bits, possible_factor);\n    } catch (err) {\n      continue;\n    }\n\n    if (sjcl.bitArray.equal(resulting_public_key_point.toBits(), original_public_key_point_bits)) {\n      return possible_factor;\n    }\n  }\n\n  throw new sjcl.exception.bug(\"unable to calculate recovery factor from signature\");\n}\n\nfunction recoverPublicKeyPointFromSignature(curve, signature_r, signature_s, hash_bits, recovery_factor) {\n  var field_order = curve.r;\n  var field_modulus = curve.field.modulus;\n  recovery_factor = recovery_factor & 3;\n  var compressed_point_y_coord_is_even = recovery_factor & 1;\n  var use_second_candidate_key = recovery_factor >> 1;\n\n  if (!FIELD_MODULUS_PLUS_ONE_DIVIDED_BY_FOUR) {\n    FIELD_MODULUS_PLUS_ONE_DIVIDED_BY_FOUR = field_modulus.add(1).div(4);\n  }\n\n  var x;\n\n  if (use_second_candidate_key) {\n    x = signature_r.add(field_order);\n  } else {\n    x = signature_r;\n  }\n\n  var alpha = x.mul(x).mul(x).add(curve.a.mul(x)).add(curve.b).mod(field_modulus);\n  var beta = alpha.powermodMontgomery(FIELD_MODULUS_PLUS_ONE_DIVIDED_BY_FOUR, field_modulus);\n  var y;\n  var beta_is_even = beta.mod(2).equals(0);\n\n  if (beta_is_even && !compressed_point_y_coord_is_even || !beta_is_even && compressed_point_y_coord_is_even) {\n    y = beta;\n  } else {\n    y = field_modulus.sub(beta);\n  }\n\n  var generated_point_R = new sjcl.ecc.point(curve, x, y);\n\n  if (!generated_point_R.isValidPoint()) {\n    throw new sjcl.exception.corrupt(\"point R. Not a valid point on the curve. Cannot recover public key\");\n  }\n\n  var message_e = sjcl.bn.fromBits(hash_bits);\n  var message_e_neg = new sjcl.bn(0).sub(message_e).mod(field_order);\n  var signature_r_inv = signature_r.inverseMod(field_order);\n  var public_key_point = generated_point_R.mult2(signature_s, message_e_neg, curve.G).mult(signature_r_inv);\n\n  if (!public_key_point.isValidPoint()) {\n    throw new sjcl.exception.corrupt(\"public_key_point. Not a valid point on the curve. Cannot recover public key\");\n  }\n\n  if (!verify_raw(curve, message_e, signature_r, signature_s, public_key_point)) {\n    throw new sjcl.exception.corrupt(\"cannot recover public key\");\n  }\n\n  return public_key_point;\n}\n\nfunction verify_raw(curve, e, r, s, public_key_point) {\n  var field_order = curve.r;\n\n  if (new sjcl.bn(1).greaterEquals(r) || r.greaterEquals(new sjcl.bn(field_order))) {\n    return false;\n  }\n\n  if (new sjcl.bn(1).greaterEquals(s) || s.greaterEquals(new sjcl.bn(field_order))) {\n    return false;\n  }\n\n  var s_mod_inverse_field_order = s.inverseMod(field_order);\n  var u1 = e.mul(s_mod_inverse_field_order).mod(field_order);\n  var u2 = r.mul(s_mod_inverse_field_order).mod(field_order);\n  var point_computed = curve.G.mult2(u1, u2, public_key_point);\n  return r.equals(point_computed.x.mod(field_order));\n}\n\nsjcl.bn.prototype.jacobi = function (that) {\n  var a = this;\n  that = new sjcl.bn(that);\n  if (that.sign() === -1) return;\n\n  if (a.equals(0)) {\n    return 0;\n  }\n\n  if (a.equals(1)) {\n    return 1;\n  }\n\n  var s = 0;\n  var e = 0;\n\n  while (!a.testBit(e)) {\n    e++;\n  }\n\n  var a1 = a.shiftRight(e);\n\n  if ((e & 1) === 0) {\n    s = 1;\n  } else {\n    var residue = that.modInt(8);\n\n    if (residue === 1 || residue === 7) {\n      s = 1;\n    } else if (residue === 3 || residue === 5) {\n      s = -1;\n    }\n  }\n\n  if (that.modInt(4) === 3 && a1.modInt(4) === 3) {\n    s = -s;\n  }\n\n  if (a1.equals(1)) {\n    return s;\n  } else {\n    return s * that.mod(a1).jacobi(a1);\n  }\n};","map":null,"metadata":{},"sourceType":"script"}