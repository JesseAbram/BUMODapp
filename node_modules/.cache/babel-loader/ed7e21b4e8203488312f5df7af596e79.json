{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/jesse/Desktop/blockx/BUMODapp/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/jesse/Desktop/blockx/BUMODapp/node_modules/@babel/runtime/helpers/createClass\");\n\nvar nacl = require('./vendor/nacl');\n\nvar sjcl = require('./vendor/sjcl');\n/**\n * Get sha256 hash string\n *\n * @param {String} bytes\n * @returns {String}\n * @private\n */\n\n\nvar sha256 = function sha256(bytes) {\n  var hash;\n  hash = sjcl.codec.bytes.fromBits(sjcl.hash.sha256.hash(sjcl.codec.bytes.toBits(bytes)));\n  return hash;\n};\n\nvar KeyPair =\n/*#__PURE__*/\nfunction () {\n  function KeyPair() {\n    _classCallCheck(this, KeyPair);\n\n    this.rawPub = '';\n    this.rawPriv = '';\n    this.generate();\n  }\n  /**\n   * Initialize the generated private key and public key.\n   */\n\n\n  _createClass(KeyPair, [{\n    key: \"generate\",\n    value: function generate() {\n      var srcKeyPair = nacl.sign.keyPair();\n      var seed = srcKeyPair.publicKey;\n      var keyPair = nacl.sign.keyPair.fromSeed(seed);\n      this.rawPriv = Array.from(seed);\n      this.rawPub = Array.from(keyPair.publicKey);\n    }\n  }, {\n    key: \"getEncPrivateKey\",\n\n    /**\n     * Get encoded private key\n     * @returns {String}\n     */\n    value: function getEncPrivateKey() {\n      if (!this.rawPriv) {\n        throw new Error('require rawPriv');\n      }\n\n      var _rawPriv = sjcl.bitArray.concat([0xda, 0x37, 0x9f, 0x1], this.rawPriv);\n\n      var nvec = sjcl.bitArray.concat(_rawPriv, [0x00]);\n      var buf = sha256(sha256(nvec)).slice(0, 4);\n      var result = sjcl.bitArray.concat(nvec, buf);\n      return sjcl.codec.base58.encode(result);\n    }\n  }, {\n    key: \"getEncPublicKey\",\n\n    /**\n     * Get encoded public key\n     * @returns {String}\n     */\n    value: function getEncPublicKey() {\n      if (!this.rawPub) {\n        throw new Error('require rawPub');\n      }\n\n      var nvec = sjcl.bitArray.concat([0xb0, 0x1], this.rawPub);\n      var buf = sha256(sha256(nvec)).slice(0, 4);\n      var result = sjcl.bitArray.concat(nvec, buf);\n      return sjcl.codec.hex.fromBits(sjcl.codec.bytes.toBits(result));\n    }\n  }, {\n    key: \"getAddress\",\n\n    /**\n     * Get hash address.\n     * @returns {String}\n     */\n    value: function getAddress() {\n      if (!this.rawPub) {\n        throw new Error('require rawPub');\n      }\n\n      var head = [0x01, 0x56, 0x1];\n      var hash = sha256(this.rawPub).slice(12);\n      var buffer = sjcl.bitArray.concat(head, hash);\n      var buf_256 = sha256(sha256(buffer)).slice(0, 4);\n      var result = sjcl.bitArray.concat(buffer, buf_256);\n      return sjcl.codec.base58.encode(result);\n    }\n  }], [{\n    key: \"getEncPublicKey\",\n    // -------------------- static methods ---------------------\n\n    /**\n     * Get encoded public key\n     * @param encPrivateKey\n     * @returns {String}\n     */\n    value: function getEncPublicKey(encPrivateKey) {\n      if (!encPrivateKey) {\n        throw new Error('require the encPrivateKey');\n      }\n\n      var rawPriv = this.parsePrivateKey(encPrivateKey);\n\n      if (!rawPriv) {\n        throw new Error('can not parse the encPrivateKey');\n      } // const keyPair = nacl.sign.keyPair.fromSeed(obj.rawPriv);\n\n\n      var keyPair = nacl.sign.keyPair.fromSeed(rawPriv);\n      return this._getPublicKey(Array.from(keyPair.publicKey));\n    }\n  }, {\n    key: \"_getPublicKey\",\n    value: function _getPublicKey(rawPub) {\n      if (!rawPub) {\n        throw new Error('require publicKey');\n      } // let nvec = sjcl.bitArray.concat([0xb0, type], rawPub);\n\n\n      var nvec = sjcl.bitArray.concat([0xb0, 0x1], rawPub);\n      var buf = sha256(sha256(nvec)).slice(0, 4);\n      var result = sjcl.bitArray.concat(nvec, buf);\n      return sjcl.codec.hex.fromBits(sjcl.codec.bytes.toBits(result));\n    }\n  }, {\n    key: \"getAddress\",\n    value: function getAddress(encPublicKey) {\n      if (!encPublicKey) {\n        throw new Error('require rawPub');\n      }\n\n      var rawPub = KeyPair.parsePublicKey(encPublicKey); // let head = [0x01, 0x56, type];\n\n      var head = [0x01, 0x56, 0x1];\n      var hash = sha256(rawPub).slice(12);\n      var buffer = sjcl.bitArray.concat(head, hash);\n      var buf_256 = sha256(sha256(buffer)).slice(0, 4);\n      var result = sjcl.bitArray.concat(buffer, buf_256);\n      return sjcl.codec.base58.encode(result);\n    }\n  }, {\n    key: \"parsePrivateKey\",\n    // Get real private key from encoded private key\n    value: function parsePrivateKey(encPrivateKey) {\n      var privKeyBits = sjcl.codec.base58.decode(encPrivateKey);\n\n      if (privKeyBits[0] !== 0xda || privKeyBits[1] !== 0x37 || privKeyBits[2] !== 0x9f) {\n        throw new Error(\"private key \".concat(encPrivateKey, \" is invalid, header is wrong\"));\n      }\n\n      if (privKeyBits[3] > 4 || privKeyBits[3] < 1) {\n        throw new Error(\"private key \".concat(encPrivateKey, \" is invalid, type is wrong\"));\n      }\n\n      var privateLength = privKeyBits.length;\n\n      if (privKeyBits[privateLength - 5] !== 0x00) {\n        throw new Error(\"private key \".concat(encPrivateKey, \" is invalid, compression bit is wrong\"));\n      }\n\n      var type = privKeyBits[3];\n      var addHeaderPriv = privKeyBits.slice(0, privateLength - 4);\n      var privHash = privKeyBits.slice(privateLength - 4, privateLength);\n      var calHash = sha256(sha256(addHeaderPriv)).slice(0, 4);\n\n      if (privHash.join() !== calHash.join()) {\n        throw new Error(\"private key \".concat(encPrivateKey, \" is invalid, hash is wrong\"));\n      }\n\n      var rawPriv = privKeyBits.slice(4, privateLength - 5);\n      return rawPriv;\n    }\n  }, {\n    key: \"parsePublicKey\",\n    // Get public key from encoded public key\n    value: function parsePublicKey(encPublicKey) {\n      var publicKeyBytes = sjcl.codec.bytes.fromBits(sjcl.codec.hex.toBits(encPublicKey));\n\n      if (publicKeyBytes[0] !== 0xb0) {\n        throw new Error(\"public key \".concat(encPublicKey, \" is invalid, header is wrong\"));\n      }\n\n      if (publicKeyBytes[1] > 4 || publicKeyBytes[1] < 1) {\n        throw new Error(\"public key \".concat(encPublicKey, \" is invalid, type is wrong\"));\n      }\n\n      var publicLength = publicKeyBytes.length;\n      var type = publicKeyBytes[1];\n      var addHeaderPub = publicKeyBytes.slice(0, publicLength - 4);\n      var pubHash = publicKeyBytes.slice(publicLength - 4, publicLength);\n      var calHash = sha256(sha256(addHeaderPub)).slice(0, 4);\n\n      if (pubHash.join() !== calHash.join()) {\n        throw new Error(\"public key \".concat(encPublicKey, \" is invalid, hash is wrong\"));\n      }\n\n      var rawPub = publicKeyBytes.slice(2, publicKeyBytes.length - 4);\n      return rawPub;\n    }\n  }, {\n    key: \"getKeyPair\",\n    value: function getKeyPair() {\n      var keypair = new KeyPair();\n      var encPrivateKey = keypair.getEncPrivateKey();\n      var encPublicKey = keypair.getEncPublicKey();\n      var address = keypair.getAddress();\n      return {\n        encPrivateKey: encPrivateKey,\n        encPublicKey: encPublicKey,\n        address: address\n      };\n    }\n  }, {\n    key: \"checkEncPrivateKey\",\n\n    /**\n     * check encPrivateKey\n     * @param  {String} encPrivateKey [encPrivateKey]\n     * @return {Boolean}               []\n     */\n    value: function checkEncPrivateKey(encPrivateKey) {\n      try {\n        if (!encPrivateKey || typeof encPrivateKey !== 'string') {\n          return false;\n        }\n\n        var privKeyBits = sjcl.codec.base58.decode(encPrivateKey.trim());\n\n        if (privKeyBits[0] !== 0xda || privKeyBits[1] !== 0x37 || privKeyBits[2] !== 0x9f || privKeyBits[3] > 4 || privKeyBits[3] < 1) {\n          return false;\n        }\n\n        var privateLength = privKeyBits.length;\n\n        if (privKeyBits[privateLength - 5] !== 0x00) {\n          return false;\n        }\n\n        var type = privKeyBits[3];\n        var addHeaderPriv = privKeyBits.slice(0, privateLength - 4);\n        var privHash = privKeyBits.slice(privateLength - 4, privateLength);\n        var calHash = sha256(sha256(addHeaderPriv)).slice(0, 4);\n\n        if (privHash.join() !== calHash.join()) {\n          return false;\n        }\n\n        return true;\n      } catch (err) {\n        return false;\n      }\n    }\n    /**\n     * check encPublicKey\n     * @param  {String} encPublicKey [encPublicKey]\n     * @return {Boolean}              []\n     */\n\n  }, {\n    key: \"checkEncPublicKey\",\n    value: function checkEncPublicKey(encPublicKey) {\n      try {\n        if (!encPublicKey || typeof encPublicKey !== 'string') {\n          return false;\n        }\n\n        var publicKeyBytes = sjcl.codec.bytes.fromBits(sjcl.codec.hex.toBits(encPublicKey.trim()));\n\n        if (publicKeyBytes[0] !== 0xb0 || publicKeyBytes[1] > 4 || publicKeyBytes[1] < 1) {\n          return false;\n        }\n\n        var publicLength = publicKeyBytes.length;\n        var type = publicKeyBytes[1];\n        var addHeaderPub = publicKeyBytes.slice(0, publicLength - 4);\n        var pubHash = publicKeyBytes.slice(publicLength - 4, publicLength);\n        var calHash = sha256(sha256(addHeaderPub)).slice(0, 4);\n\n        if (pubHash.join() !== calHash.join()) {\n          return false;\n        }\n\n        return true;\n      } catch (err) {\n        return false;\n      }\n    }\n    /**\n     * check address\n     * @param  {String} address [address]\n     * @return {Boolean}         []\n     */\n\n  }, {\n    key: \"checkAddress\",\n    value: function checkAddress(address) {\n      try {\n        if (!address || typeof address !== 'string') {\n          return false;\n        }\n\n        var addressArr = sjcl.codec.base58.decode(address.trim());\n        var head = sjcl.bitArray.concat([0x01, 0x56, 0x1], []);\n\n        if (!Array.isArray(addressArr) || addressArr[0] !== head[0] || addressArr[1] !== head[1] || addressArr[2] !== head[2] || addressArr.length !== 27) {\n          return false;\n        } // addressArr = `addrHead` concat `addrHash`\n\n\n        var arrLength = addressArr.length;\n        var addrHead = addressArr.slice(0, arrLength - 4);\n        var addrHash = addressArr.slice(arrLength - 4, arrLength);\n        var testHash = sha256(sha256(addrHead)).slice(0, 4);\n\n        if (addrHash.join() !== testHash.join()) {\n          return false;\n        }\n\n        return true;\n      } catch (err) {\n        return false;\n      }\n    }\n  }]);\n\n  return KeyPair;\n}();\n/**\n * Expose `KeyPair`\n */\n\n\nmodule.exports = KeyPair;","map":null,"metadata":{},"sourceType":"script"}